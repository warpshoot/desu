<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>DESU‚Ñ¢ Paint</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            background: #4d4d4d;
        }

        #canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: pixelated;
            image-rendering: -webkit-optimize-contrast;
            touch-action: none;
            transform-origin: 0 0;
        }

        /* Êäï„ÅíÁ∏ÑÁî®„Ç™„Éº„Éê„Éº„É¨„Ç§„Ç≠„É£„É≥„Éê„Çπ */
        #lasso-canvas {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 50;
        }

        /* Â∑¶‰∏ã„ÉÑ„Éº„É´„Éê„Éº */
        #toolbar-left {
            position: fixed;
            left: 12px;
            bottom: 120px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        /* Âè≥‰∏ä„ÉÑ„Éº„É´„Éê„Éº */
        #toolbar-right {
            position: fixed;
            top: max(12px, env(safe-area-inset-top));
            right: 12px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .tool-btn {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            border: 2px solid #666;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            cursor: pointer;
            transition: transform 0.1s, background 0.1s;
            color: #333;
        }

        .tool-btn svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .tool-btn svg .filled {
            fill: currentColor;
            stroke: none;
        }

        body.dark .tool-btn {
            background: rgba(40, 40, 40, 0.9);
            border-color: #888;
            color: #fff;
        }

        .tool-btn:active {
            transform: scale(0.92);
        }

        .tool-btn.active {
            background: #333;
            border-color: #fff;
            color: #fff;
        }

        body.dark .tool-btn.active {
            background: #fff;
            border-color: #333;
            color: #333;
        }

        /* Á∏¶„Çπ„É©„Ç§„ÉÄ„Éº */
        #size-slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            margin-top: 8px;
            width: 48px;
        }

        #brushSize {
            -webkit-appearance: none;
            appearance: none;
            width: 100px;
            height: 6px;
            background: #888;
            border-radius: 3px;
            transform: rotate(-90deg);
            transform-origin: center center;
            margin: 47px 0;
        }

        body.dark #brushSize {
            background: #888;
        }

        #brushSize::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #333;
            border-radius: 50%;
            border: 2px solid #fff;
        }

        body.dark #brushSize::-webkit-slider-thumb {
            background: #fff;
            border-color: #333;
        }

        #sizeDisplay {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 4px 8px;
            border-radius: 6px;
            min-width: 32px;
            text-align: center;
        }

        body.dark #sizeDisplay {
            color: #fff;
            background: rgba(40, 40, 40, 0.9);
        }

        /* „Ç∫„Éº„É†„É™„Çª„ÉÉ„Éà„Éú„Çø„É≥Ôºà„Ç∫„Éº„É†‰∏≠„ÅÆ„ÅøË°®Á§∫Ôºâ */
        #resetZoomBtn {
            display: none;
            position: fixed;
            bottom: max(20px, calc(env(safe-area-inset-bottom) + 12px));
            right: max(20px, calc(env(safe-area-inset-right) + 12px));
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 2px solid #666;
            background: rgba(255, 255, 255, 0.9);
            z-index: 100;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #333;
        }

        #resetZoomBtn svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        body.dark #resetZoomBtn {
            background: rgba(40, 40, 40, 0.9);
            border-color: #888;
            color: #fff;
        }

        #resetZoomBtn.visible {
            display: flex;
        }

        /* ‰øùÂ≠ò„É¢„Éº„ÉÄ„É´ */
        #save-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 200;
        }

        #save-ui {
            display: none;
            position: fixed;
            top: max(20px, env(safe-area-inset-top));
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 16px 24px;
            border-radius: 12px;
            z-index: 201;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: opacity 0.2s;
        }

        #save-ui.hidden-during-selection {
            opacity: 0;
            pointer-events: none;
        }

        body.dark #save-ui {
            background: rgba(30, 30, 30, 0.95);
            color: #fff;
        }

        #save-ui h3 {
            font-size: 14px;
            margin-bottom: 12px;
            font-weight: normal;
            color: #666;
        }

        body.dark #save-ui h3 {
            color: #aaa;
        }

        #save-ui label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            margin-bottom: 8px;
        }

        #save-ui input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        .option-group {
            margin-bottom: 8px;
            font-size: 13px;
        }

        .option-group-label {
            font-size: 11px;
            color: #999;
            margin-bottom: 4px;
        }

        body.dark .option-group-label {
            color: #666;
        }

        .option-buttons {
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .option-btn {
            padding: 4px 10px;
            border: 1px solid #999;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.1s;
        }

        body.dark .option-btn {
            background: rgba(60, 60, 60, 0.5);
            border-color: #666;
        }

        .option-btn.active {
            background: #333;
            color: #fff;
            border-color: #333;
        }

        body.dark .option-btn.active {
            background: #fff;
            color: #333;
            border-color: #fff;
        }

        .option-btn.disabled {
            opacity: 0.3;
            pointer-events: none;
            cursor: not-allowed;
        }

        /* Á¢∫ÂÆö„É¢„Éº„ÉâÊôÇ„ÅØ„Ç™„Éó„Ç∑„Éß„É≥ÈÉ®ÂàÜ„ÇíÈùûË°®Á§∫ */
        #save-ui.in-confirmation-mode .option-group,
        #save-ui.in-confirmation-mode label,
        #save-ui.in-confirmation-mode #saveAllBtn {
            display: none;
        }

        #save-ui.in-confirmation-mode h3 {
            margin-bottom: 16px;
        }

        .save-btn {
            padding: 10px 20px;
            margin: 0 4px;
            border: 1px solid #333;
            background: #fff;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
        }

        body.dark .save-btn {
            background: #444;
            border-color: #888;
            color: #fff;
        }

        .save-btn:active {
            transform: scale(0.96);
        }

        .save-btn.primary {
            background: #333;
            color: #fff;
        }

        body.dark .save-btn.primary {
            background: #fff;
            color: #333;
        }

        /* ÈÅ∏ÊäûÁØÑÂõ≤„Ç≠„É£„É≥„Éê„Çπ */
        #selection-canvas {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 199;
        }

        /* „Éï„É©„ÉÉ„Ç∑„É•„Ç®„Éï„Çß„ÇØ„Éà */
        #flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            opacity: 0;
            pointer-events: none;
            z-index: 300;
            transition: opacity 0.1s;
        }

        /* ÁîüÊàê‰∏≠„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº */
        #generating {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 24px 48px;
            border-radius: 16px;
            z-index: 250;
            font-size: 16px;
            min-width: 280px;
            text-align: center;
        }

        #progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin-top: 16px;
            overflow: hidden;
            position: relative;
        }

        #progress-fill {
            height: 100%;
            background: #fff;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        #progress-text {
            margin-top: 8px;
            font-size: 13px;
            opacity: 0.8;
        }

        /* „Çπ„Éî„Éä„Éº„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: -4px;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞Ë°®Á§∫ */
        #debug-log {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            max-height: 200px;
            background: rgba(0, 0, 0, 0.95);
            color: #0f0;
            font-family: monospace;
            font-size: 11px;
            padding: 8px;
            overflow-y: auto;
            z-index: 999;
            border-top: 2px solid #0f0;
        }

        #debug-log.visible {
            display: block;
        }

        #debug-log div {
            margin: 2px 0;
            word-wrap: break-word;
        }

        #debug-toggle {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 0, 0.3);
            border: 2px solid #0f0;
            border-radius: 50%;
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
        }

        #debug-toggle.visible {
            display: flex;
        }

        /* Â∑¶‰∏ãÈö†„Åó„Ç®„É™„Ç¢Ôºà„Éá„Éê„ÉÉ„Ç∞„Éú„Çø„É≥Ë°®Á§∫Áî®Ôºâ */
        #debug-activator {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 60px;
            height: 60px;
            z-index: 999;
        }

        /* „ÇØ„É¨„Ç∏„ÉÉ„Éà„Éú„Çø„É≥ */
        #credit-btn {
            position: fixed;
            top: max(12px, env(safe-area-inset-top));
            left: 12px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s;
        }

        #credit-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
            border-color: rgba(255, 255, 255, 0.5);
        }

        body.dark #credit-btn {
            border-color: rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.4);
        }

        body.dark #credit-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.7);
        }

        /* „ÇØ„É¨„Ç∏„ÉÉ„Éà„É¢„Éº„ÉÄ„É´ */
        #credit-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 300;
            align-items: center;
            justify-content: center;
        }

        #credit-modal.visible {
            display: flex;
        }

        #credit-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 32px;
            border-radius: 16px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        body.dark #credit-content {
            background: rgba(30, 30, 30, 0.95);
            color: #fff;
        }

        #credit-content h2 {
            font-size: 24px;
            margin-bottom: 16px;
            font-weight: bold;
        }

        #credit-logo {
            width: 120px;
            height: 120px;
            margin: 16px auto;
            cursor: pointer;
        }

        #credit-logo img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #credit-author {
            font-size: 16px;
            margin-top: 16px;
        }

        #credit-author a {
            color: #333;
            text-decoration: none;
            font-weight: bold;
        }

        body.dark #credit-author a {
            color: #fff;
        }

        #credit-author a:hover {
            text-decoration: underline;
        }

        #credit-close {
            margin-top: 24px;
            padding: 10px 24px;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }

        body.dark #credit-close {
            background: #fff;
            color: #333;
        }

        #credit-close:active {
            transform: scale(0.96);
        }
    </style>
</head>
<body class="light">
    <canvas id="canvas"></canvas>
    <canvas id="lasso-canvas"></canvas>

    <!-- Â∑¶‰∏ã„ÉÑ„Éº„É´„Éê„Éº -->
    <div id="toolbar-left">
        <div class="tool-btn active" id="penBtn" data-tool="pen">
            <svg viewBox="0 0 24 24">
                <path d="M4 18 Q8 8 12 12 Q16 16 20 6" fill="none"/>
            </svg>
        </div>
        <div class="tool-btn" id="fillBtn" data-tool="fill">
            <svg viewBox="0 0 24 24">
                <path d="M6 8 L10 4 L18 12 L14 16 Z" class="filled"/>
                <path d="M16 16 Q18 18 17 21 Q16 24 15 21 Q14 18 16 16 Z" class="filled"/>
            </svg>
        </div>
        <div class="tool-btn" id="colorBtn">
            <svg viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="8" id="colorCircle" class="filled"/>
            </svg>
        </div>
        <div id="size-slider-container">
            <input type="range" id="brushSize" min="1" max="20" value="1">
            <span id="sizeDisplay">1</span>
        </div>
    </div>

    <!-- Âè≥‰∏ä„ÉÑ„Éº„É´„Éê„Éº -->
    <div id="toolbar-right">
        <div class="tool-btn" id="saveBtn">
            <svg viewBox="0 0 24 24">
                <path d="M12 4 L12 16 M6 12 L12 18 L18 12"/>
                <path d="M4 20 L20 20"/>
            </svg>
        </div>
        <div class="tool-btn" id="clearBtn">
            <svg viewBox="0 0 24 24">
                <path d="M12 4 L12 2 M12 22 L12 20 M4 12 L2 12 M22 12 L20 12 M6.34 6.34 L4.93 4.93 M19.07 19.07 L17.66 17.66 M6.34 17.66 L4.93 19.07 M19.07 4.93 L17.66 6.34"/>
            </svg>
        </div>
        <div class="tool-btn" id="invertBtn">
            <svg viewBox="0 0 24 24">
                <path d="M12 4 A8 8 0 0 0 12 20 Z"/>
                <path d="M12 4 A8 8 0 0 1 12 20 Z" class="filled"/>
            </svg>
        </div>
    </div>

    <!-- „Ç∫„Éº„É†„É™„Çª„ÉÉ„Éà„Éú„Çø„É≥ -->
    <div id="resetZoomBtn">
        <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="8"/>
            <path d="M12 7 L12 17 M7 12 L17 12"/>
        </svg>
    </div>

    <!-- ‰øùÂ≠òUI -->
    <div id="save-overlay"></div>
    <div id="save-ui">
        <h3>ÁØÑÂõ≤„Çí„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶ÈÅ∏Êäû</h3>

        <div class="option-group">
            <div class="option-group-label">Á∏¶Ê®™ÊØî</div>
            <div class="option-buttons">
                <button class="option-btn active" data-aspect="free">Ëá™Áî±</button>
                <button class="option-btn" data-aspect="1:1">1:1</button>
                <button class="option-btn" data-aspect="4:5">4:5</button>
                <button class="option-btn" data-aspect="16:9">16:9</button>
                <button class="option-btn" data-aspect="9:16">9:16</button>
            </div>
        </div>

        <div class="option-group">
            <div class="option-group-label">ÂÄçÁéá</div>
            <div class="option-buttons">
                <button class="option-btn active" data-scale="1">1x</button>
                <button class="option-btn" data-scale="2">2x</button>
                <button class="option-btn" data-scale="3">3x</button>
            </div>
        </div>

        <div class="option-group">
            <div class="option-group-label">„Éé„Ç§„Ç∫</div>
            <div class="option-buttons">
                <button class="option-btn" data-noise="0">0</button>
                <button class="option-btn active" data-noise="1">1</button>
                <button class="option-btn" data-noise="2">2</button>
                <button class="option-btn" data-noise="3">3</button>
            </div>
        </div>

        <label>
            <input type="checkbox" id="transparentBg">
            ËÉåÊôØÈÄèÈÅé
        </label>

        <div>
            <button class="save-btn" id="saveAllBtn">ÂÖ®‰Ωì„Çí‰øùÂ≠ò</button>
            <button class="save-btn primary" id="confirmSelectionBtn" style="display:none;">Á¢∫ÂÆö</button>
            <button class="save-btn" id="redoSelectionBtn" style="display:none;">„ÇÑ„ÇäÁõ¥„Åó</button>
            <button class="save-btn" id="cancelSaveBtn">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <canvas id="selection-canvas"></canvas>
    <div id="flash"></div>
    <div id="generating">
        <div><span class="spinner"></span>GIFÁîüÊàê‰∏≠...</div>
        <div id="progress-bar">
            <div id="progress-fill"></div>
        </div>
        <div id="progress-text">Ê∫ñÂÇô‰∏≠...</div>
    </div>

    <!-- „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞ -->
    <div id="debug-activator"></div>
    <div id="debug-toggle">üêõ</div>
    <div id="debug-log"></div>

    <!-- „ÇØ„É¨„Ç∏„ÉÉ„Éà„Éú„Çø„É≥„Å®„É¢„Éº„ÉÄ„É´ -->
    <div id="credit-btn">?</div>
    <div id="credit-modal">
        <div id="credit-content">
            <h2>DESU‚Ñ¢ PAINT</h2>
            <a href="https://warpshoot.github.io/desu/" target="_blank" id="credit-logo">
                <img src="https://warpshoot.github.io/desu/logo.gif" alt="DESU PAINT Logo">
            </a>
            <div id="credit-author">
                by <a href="https://warpshoot.github.io/" target="_blank">wpy</a>
            </div>
            <button id="credit-close">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <!-- gif.js CDN -->
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>

    <script>
        // ============================================
        // DESU‚Ñ¢ Paint - iPadÂ∞ÇÁî®Áâà v4 (GIFÊåØÂãïÊ©üËÉΩËøΩÂä†)
        // ============================================

        // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞Ê©üËÉΩ
        const debugLog = document.getElementById('debug-log');
        const debugToggle = document.getElementById('debug-toggle');
        const debugActivator = document.getElementById('debug-activator');
        let debugVisible = false;
        let debugButtonVisible = false;
        let debugActivatorTimer = null;
        let debugToggleTimer = null;

        // Â∑¶‰∏ãÈï∑Êäº„ÅóÔºà500msÔºâ„Åß„Éá„Éê„ÉÉ„Ç∞„Éú„Çø„É≥Ë°®Á§∫
        debugActivator.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            debugActivatorTimer = setTimeout(() => {
                if (!debugButtonVisible) {
                    debugButtonVisible = true;
                    debugToggle.classList.add('visible');
                }
                debugActivatorTimer = null;
            }, 500);
        });

        debugActivator.addEventListener('pointerup', () => {
            if (debugActivatorTimer) {
                clearTimeout(debugActivatorTimer);
                debugActivatorTimer = null;
            }
        });

        debugActivator.addEventListener('pointercancel', () => {
            if (debugActivatorTimer) {
                clearTimeout(debugActivatorTimer);
                debugActivatorTimer = null;
            }
        });

        // „Éá„Éê„ÉÉ„Ç∞„Éú„Çø„É≥Ôºö„ÇØ„É™„ÉÉ„ÇØÔºàÁü≠Êäº„ÅóÔºâ„Åß„É≠„Ç∞Ë°®Á§∫Âàá„ÇäÊõø„Åà„ÄÅÈï∑Êäº„ÅóÔºà500msÔºâ„Åß„Éú„Çø„É≥ÈùûË°®Á§∫
        debugToggle.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            debugToggleTimer = setTimeout(() => {
                // Èï∑Êäº„Åó ‚Üí „Éú„Çø„É≥ÈùûË°®Á§∫
                debugButtonVisible = false;
                debugToggle.classList.remove('visible');
                debugLog.classList.remove('visible');
                debugVisible = false;
                debugToggleTimer = null;
            }, 500);
        });

        debugToggle.addEventListener('pointerup', () => {
            if (debugToggleTimer) {
                // Áü≠Êäº„Åó ‚Üí „É≠„Ç∞Ë°®Á§∫Âàá„ÇäÊõø„Åà
                clearTimeout(debugToggleTimer);
                debugToggleTimer = null;

                debugVisible = !debugVisible;
                if (debugVisible) {
                    debugLog.classList.add('visible');
                } else {
                    debugLog.classList.remove('visible');
                }
            }
        });

        debugToggle.addEventListener('pointercancel', () => {
            if (debugToggleTimer) {
                clearTimeout(debugToggleTimer);
                debugToggleTimer = null;
            }
        });

        // ÂÖÉ„ÅÆconsole.log„Å®console.error„Çí‰øùÂ≠ò
        const originalLog = console.log;
        const originalError = console.error;

        function addToDebugLog(message, isError = false) {
            const div = document.createElement('div');
            if (isError) {
                div.style.color = '#f00';
            }
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            debugLog.appendChild(div);
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        // console.log„Çí‰∏äÊõ∏„Åç
        console.log = function(...args) {
            originalLog.apply(console, args);
            const message = args.map(arg =>
                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
            ).join(' ');
            addToDebugLog(message, false);
        };

        // console.error„Çí‰∏äÊõ∏„Åç
        console.error = function(...args) {
            originalError.apply(console, args);
            const message = 'ERROR: ' + args.map(arg =>
                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
            ).join(' ');
            addToDebugLog(message, true);
        };

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const lassoCanvas = document.getElementById('lasso-canvas');
        const lassoCtx = lassoCanvas.getContext('2d');

        // --- Áä∂ÊÖã ---
        let isDarkMode = false;
        let currentTool = 'pen';  // 'pen' or 'fill'
        let currentColor = 'black';  // 'black' or 'white'
        let isDrawing = false;
        let lastX = 0, lastY = 0;

        // „Ç∫„Éº„É†/„Éë„É≥
        let scale = 1;
        let translateX = 0, translateY = 0;

        // Ëâ≤„Åî„Å®„ÅÆ„Éñ„É©„Ç∑„Çµ„Ç§„Ç∫‰øùÊåÅ
        const colorSizes = { black: 1, white: 5 };

        // undo/redoÁî®ÔºàImageBitmapÊñπÂºèÔºâ
        let undoStack = [];
        let redoStack = [];
        const MAX_HISTORY = 15;

        // „Éù„Ç§„É≥„Çø„ÉºÁÆ°ÁêÜ
        let activePointers = new Map();
        let pencilDetected = false;

        // „Çø„ÉÉ„ÉóÂà§ÂÆöÁî®
        let touchStartTime = 0;
        let touchStartPos = null;
        let maxFingers = 0;
        let strokeMade = false;

        // „Éî„É≥„ÉÅÁî®
        let lastPinchDist = 0;
        let lastPinchCenter = { x: 0, y: 0 };
        let initialPinchDist = 0;
        let initialPinchCenter = { x: 0, y: 0 };
        let isPinching = false;

        // Êäï„ÅíÁ∏ÑÁî®
        let lassoPoints = [];
        let isLassoing = false;

        // ‰øùÂ≠ò„É¢„Éº„Éâ
        let isSaveMode = false;
        let selectionStart = null;
        let selectionEnd = null;
        let confirmedSelection = null;  // Á¢∫ÂÆö„Åó„ÅüÈÅ∏ÊäûÁØÑÂõ≤ {x, y, w, h}
        let selectedAspect = 'free';  // 'free', '1:1', '4:5', '16:9', '9:16'
        let selectedScale = 1;        // 1, 2, 3
        let selectedNoise = 1;        // 0, 1, 2, 3

        // ============================================
        // ÂàùÊúüÂåñ
        // ============================================

        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            lassoCanvas.width = window.innerWidth;
            lassoCanvas.height = window.innerHeight;

            const selCanvas = document.getElementById('selection-canvas');
            selCanvas.width = window.innerWidth;
            selCanvas.height = window.innerHeight;

            applyTransform();
            updateColorButton();
            saveState();
        }

        function applyTransform() {
            canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;

            const resetBtn = document.getElementById('resetZoomBtn');
            if (Math.abs(scale - 1) > 0.01 || Math.abs(translateX) > 1 || Math.abs(translateY) > 1) {
                resetBtn.classList.add('visible');
            } else {
                resetBtn.classList.remove('visible');
            }
        }

        function getCanvasPoint(clientX, clientY) {
            return {
                x: Math.floor((clientX - translateX) / scale),
                y: Math.floor((clientY - translateY) / scale)
            };
        }

        // ÁèæÂú®„ÅÆÊèèÁîªËâ≤„ÇíÂèñÂæó
        function getDrawColor() {
            if (currentColor === 'black') {
                return isDarkMode ? '#fff' : '#000';
            } else {
                return isDarkMode ? '#000' : '#fff';
            }
        }

        // Ëâ≤„Éú„Çø„É≥„ÅÆË°®Á§∫Êõ¥Êñ∞
        function updateColorButton() {
            const circle = document.getElementById('colorCircle');

            // ÈªíÈÅ∏ÊäûÊôÇ„ÅØÂ°ó„Çä„Å§„Å∂„Åó„ÄÅÁôΩÈÅ∏ÊäûÊôÇ„ÅØÁôΩÊäú„ÅçÔºà„Çπ„Éà„É≠„Éº„ÇØ„ÅÆ„ÅøÔºâ
            if (currentColor === 'black') {
                circle.classList.add('filled');
                circle.style.stroke = 'none';
            } else {
                circle.classList.remove('filled');
                circle.style.stroke = 'currentColor';
                circle.style.strokeWidth = '2';
            }
        }

        // ============================================
        // ÊèèÁîª„Ç®„É≥„Ç∏„É≥Ôºà2ÂÄ§„Éª„Éñ„É¨„Çº„É≥„Éè„É†Ôºâ
        // ============================================

        function drawLine(x1, y1, x2, y2) {
            const size = colorSizes[currentColor];
            ctx.fillStyle = getDrawColor();

            const r = Math.floor(size / 2);
            let dx = Math.abs(x2 - x1), sx = x1 < x2 ? 1 : -1;
            let dy = -Math.abs(y2 - y1), sy = y1 < y2 ? 1 : -1;
            let err = dx + dy;

            while (true) {
                if (size === 1) {
                    ctx.fillRect(x1, y1, 1, 1);
                } else {
                    ctx.fillRect(x1 - r, y1 - r, size, size);
                }

                if (x1 === x2 && y1 === y2) break;
                const e2 = 2 * err;
                if (e2 >= dy) { err += dy; x1 += sx; }
                if (e2 <= dx) { err += dx; y1 += sy; }
            }
        }

        // ============================================
        // Â°ó„Çä„Å§„Å∂„ÅóÔºà„Çπ„Ç≠„É£„É≥„É©„Ç§„É≥Ê≥ïÔºâ
        // ============================================

        function floodFill(startX, startY) {
            const w = canvas.width, h = canvas.height;

            if (startX < 0 || startX >= w || startY < 0 || startY >= h) return;

            const imgData = ctx.getImageData(0, 0, w, h);
            const data = imgData.data;

            const idx = (startY * w + startX) * 4;
            const targetR = data[idx], targetG = data[idx + 1], targetB = data[idx + 2];

            // Â°ó„Çä„Å§„Å∂„ÅóËâ≤„ÇíÊ±∫ÂÆö
            const fillColorHex = getDrawColor();
            const fillColor = fillColorHex === '#fff' || fillColorHex === '#FFF'
                ? [255, 255, 255]
                : [0, 0, 0];

            if (targetR === fillColor[0] && targetG === fillColor[1] && targetB === fillColor[2]) return;

            const matchTarget = (i) => data[i] === targetR && data[i + 1] === targetG && data[i + 2] === targetB;
            const setPixel = (i) => {
                data[i] = fillColor[0];
                data[i + 1] = fillColor[1];
                data[i + 2] = fillColor[2];
                data[i + 3] = 255;
            };

            const stack = [[startX, startY]];

            while (stack.length > 0) {
                let [x, y] = stack.pop();
                let i = (y * w + x) * 4;

                while (x >= 0 && matchTarget(i)) {
                    x--;
                    i -= 4;
                }
                x++;
                i += 4;

                let spanAbove = false, spanBelow = false;

                while (x < w && matchTarget(i)) {
                    setPixel(i);

                    if (y > 0) {
                        const above = i - w * 4;
                        if (matchTarget(above)) {
                            if (!spanAbove) {
                                stack.push([x, y - 1]);
                                spanAbove = true;
                            }
                        } else {
                            spanAbove = false;
                        }
                    }

                    if (y < h - 1) {
                        const below = i + w * 4;
                        if (matchTarget(below)) {
                            if (!spanBelow) {
                                stack.push([x, y + 1]);
                                spanBelow = true;
                            }
                        } else {
                            spanBelow = false;
                        }
                    }

                    x++;
                    i += 4;
                }
            }

            ctx.putImageData(imgData, 0, 0);
        }

        // ============================================
        // Êäï„ÅíÁ∏ÑÂ°ó„Çä„Å§„Å∂„Åó
        // ============================================

        function startLasso(x, y) {
            isLassoing = true;
            lassoPoints = [{ x, y }];
            lassoCanvas.style.display = 'block';
            lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
        }

        function updateLasso(x, y) {
            if (!isLassoing) return;

            lassoPoints.push({ x, y });

            // Èùí„ÅÑÁ∑ö„ÅßËªåË∑°„ÇíÊèèÁîª
            lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
            lassoCtx.strokeStyle = '#0066ff';
            lassoCtx.lineWidth = 2;
            lassoCtx.beginPath();
            lassoCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
            for (let i = 1; i < lassoPoints.length; i++) {
                lassoCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
            }
            // ÂßãÁÇπ„Å´Êàª„ÇãÁ∑öÔºà„Éó„É¨„Éì„É•„ÉºÔºâ
            lassoCtx.lineTo(lassoPoints[0].x, lassoPoints[0].y);
            lassoCtx.stroke();
        }

        function finishLasso() {
            if (!isLassoing || lassoPoints.length < 3) {
                isLassoing = false;
                lassoPoints = [];
                lassoCanvas.style.display = 'none';
                return false;
            }

            // ÁîªÈù¢Â∫ßÊ®ô„Åã„Çâ„Ç≠„É£„É≥„Éê„ÇπÂ∫ßÊ®ô„Å´Â§âÊèõ
            const canvasPoints = lassoPoints.map(p => getCanvasPoint(p.x, p.y));

            // Êäï„ÅíÁ∏Ñ„ÅÆÂÜÖÂÅ¥„ÇíÂ°ó„Çä„Å§„Å∂„Åó
            fillPolygon(canvasPoints);

            isLassoing = false;
            lassoPoints = [];
            lassoCanvas.style.display = 'none';
            lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);

            return true;
        }

        function fillPolygon(points) {
            if (points.length < 3) return;

            ctx.fillStyle = getDrawColor();
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.fill();

            // „Ç¢„É≥„ÉÅ„Ç®„Ç§„É™„Ç¢„Çπ„ÅßÁô∫Áîü„Åó„Åü‰∏≠ÈñìËâ≤„Çí2ÂÄ§Âåñ
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                const val = avg > 127 ? 255 : 0;
                data[i] = val;
                data[i + 1] = val;
                data[i + 2] = val;
            }
            ctx.putImageData(imgData, 0, 0);
        }

        // ============================================
        // undo/redoÔºàImageBitmapÊñπÂºèÔºâ
        // ============================================

        async function saveState() {
            const bitmap = await createImageBitmap(canvas);
            undoStack.push(bitmap);

            if (undoStack.length > MAX_HISTORY) {
                undoStack.shift().close();
            }

            redoStack.forEach(b => b.close());
            redoStack = [];
        }

        function undo() {
            if (undoStack.length <= 1) return;

            const current = undoStack.pop();
            redoStack.push(current);

            const prev = undoStack[undoStack.length - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(prev, 0, 0);
        }

        function redo() {
            if (redoStack.length === 0) return;

            const next = redoStack.pop();
            undoStack.push(next);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(next, 0, 0);
        }

        // ============================================
        // GIFÁîüÊàêÔºà„Éî„ÇØ„Çª„É´ÊåØÂãïÔºâ
        // ============================================

        function generateGlitchFrames(imgData, transparent, noiseLevel = 1) {
            const w = imgData.width;
            const h = imgData.height;
            const data = imgData.data;

            // ËÉåÊôØËâ≤Âà§ÂÆöÁî®
            const bgR = isDarkMode ? 0 : 255;
            const bgG = isDarkMode ? 0 : 255;
            const bgB = isDarkMode ? 0 : 255;

            // Èªí„Éâ„ÉÉ„ÉàÔºàÊèèÁîªÈÉ®ÂàÜÔºâ„ÅÆÂ∫ßÊ®ô„ÇíÂèéÈõÜ
            const pixels = [];
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // ËÉåÊôØËâ≤„Åß„Å™„ÅÑ = ÊèèÁîªÈÉ®ÂàÜ
                    if (r !== bgR || g !== bgG || b !== bgB) {
                        pixels.push({ x, y, r, g, b });
                    }
                }
            }

            // „Ç∑„Éº„ÉâÂèØËÉΩ„Å™Áñë‰ºº‰π±Êï∞ÁîüÊàêÂô®
            function seededRandom(seed) {
                let x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            }

            // „Éé„Ç§„Ç∫„É¨„Éô„É´„Å´Âøú„Åò„Åü„Éë„Éº„Çª„É≥„ÉÜ„Éº„Ç∏Ë®≠ÂÆö„Å®Âãï‰Ωú
            const noiseLevelSettings = {
                1: { mode: 'normal', percentages: [0.1, 0.3, 0.3] },           // Âº±: 10%, 30%, 30% (1pxÁßªÂãï)
                2: { mode: 'large-offset', percentages: [1.0, 1.0, 1.0] },     // ‰∏≠: 100% (2-5pxÁßªÂãï)
                3: { mode: 'random-position', percentages: [0.7, 0.85, 1.0] }  // Âº∑: 70%, 85%, 100% (ÂÆåÂÖ®„É©„É≥„ÉÄ„É†ÈÖçÁΩÆ)
            };
            const noiseSetting = noiseLevelSettings[noiseLevel] || noiseLevelSettings[1];
            const noisePercentages = noiseSetting.percentages;
            const noiseMode = noiseSetting.mode;

            // „Éï„É¨„Éº„É†ÁîüÊàêÈñ¢Êï∞ÔºàÁï∞„Å™„ÇãÂÅè„ÇäÊñπ„Å®„Éé„Ç§„Ç∫ÈáèÔºâ
            function createFrame(seed, distributionMode, noisePercentage = 0.3, glitchMode = 'normal') {
                const frameData = new Uint8ClampedArray(data);
                const frameCopy = new ImageData(frameData, w, h);
                const targetPixels = [...pixels];

                let randomSeed = seed * 1000;

                // „É¢„Éº„Éâ„Å´„Çà„Å£„Å¶Áï∞„Å™„ÇãÂàÜÂ∏ÉÊñπÊ≥ï„Çí‰ΩøÁî®
                if (distributionMode === 'bottom-bias') {
                    // ‰∏ãÂÅ¥„Å´ÂÅè„Çã„Éé„Ç§„Ç∫ÔºàÂÖÉ„ÅÆsortÊñπÂºèÔºâ
                    targetPixels.sort(() => seededRandom(randomSeed++) - 0.5);
                } else if (distributionMode === 'uniform') {
                    // ÂùáÁ≠âÂàÜÂ∏ÉÔºàFisher-Yates„Ç∑„É£„ÉÉ„Éï„É´Ôºâ
                    for (let i = targetPixels.length - 1; i > 0; i--) {
                        const j = Math.floor(seededRandom(randomSeed++) * (i + 1));
                        [targetPixels[i], targetPixels[j]] = [targetPixels[j], targetPixels[i]];
                    }
                } else if (distributionMode === 'top-bias') {
                    // ‰∏äÂÅ¥„Å´ÂÅè„Çã„Éé„Ç§„Ç∫ÔºàÈÄÜÈ†ÜsortÔºâ
                    targetPixels.sort(() => 0.5 - seededRandom(randomSeed++));
                }

                // ÊåáÂÆö„Åï„Çå„ÅüÂâ≤Âêà„Åß„É©„É≥„ÉÄ„É†ÈÅ∏Êäû
                const count = Math.floor(pixels.length * noisePercentage);
                const shuffled = targetPixels.slice(0, count);

                if (glitchMode === 'random-position') {
                    // „É¨„Éô„É´3: ÂÆåÂÖ®„É©„É≥„ÉÄ„É†ÈÖçÁΩÆ
                    shuffled.forEach(p => {
                        const newX = Math.floor(seededRandom(randomSeed++) * w);
                        const newY = Math.floor(seededRandom(randomSeed++) * h);

                        const oldIdx = (p.y * w + p.x) * 4;
                        const newIdx = (newY * w + newX) * 4;

                        // ÂÖÉ„ÅÆ‰ΩçÁΩÆ„ÇíËÉåÊôØËâ≤„ÅßÂ°ó„Çä„Å§„Å∂„Åó
                        frameData[oldIdx] = bgR;
                        frameData[oldIdx + 1] = bgG;
                        frameData[oldIdx + 2] = bgB;
                        if (transparent) frameData[oldIdx + 3] = 0;

                        // Êñ∞„Åó„ÅÑ‰ΩçÁΩÆ„Å´ÊèèÁîª
                        frameData[newIdx] = p.r;
                        frameData[newIdx + 1] = p.g;
                        frameData[newIdx + 2] = p.b;
                        frameData[newIdx + 3] = 255;
                    });
                } else if (glitchMode === 'large-offset') {
                    // „É¨„Éô„É´2: 2ÔΩû5„Éî„ÇØ„Çª„É´„ÅÆ„É©„É≥„ÉÄ„É†Ë∑ùÈõ¢ÁßªÂãï
                    shuffled.forEach(p => {
                        const distance = Math.floor(seededRandom(randomSeed++) * 4) + 2; // 2ÔΩû5
                        const angle = seededRandom(randomSeed++) * Math.PI * 2;
                        const offsetX = Math.round(Math.cos(angle) * distance);
                        const offsetY = Math.round(Math.sin(angle) * distance);

                        const newX = p.x + offsetX;
                        const newY = p.y + offsetY;

                        if (newX >= 0 && newX < w && newY >= 0 && newY < h) {
                            const oldIdx = (p.y * w + p.x) * 4;
                            const newIdx = (newY * w + newX) * 4;

                            // ÂÖÉ„ÅÆ‰ΩçÁΩÆ„ÇíËÉåÊôØËâ≤„ÅßÂ°ó„Çä„Å§„Å∂„Åó
                            frameData[oldIdx] = bgR;
                            frameData[oldIdx + 1] = bgG;
                            frameData[oldIdx + 2] = bgB;
                            if (transparent) frameData[oldIdx + 3] = 0;

                            // Êñ∞„Åó„ÅÑ‰ΩçÁΩÆ„Å´ÊèèÁîª
                            frameData[newIdx] = p.r;
                            frameData[newIdx + 1] = p.g;
                            frameData[newIdx + 2] = p.b;
                            frameData[newIdx + 3] = 255;
                        }
                    });
                } else {
                    // „É¨„Éô„É´1: ÈÄöÂ∏∏„ÅÆ8ÊñπÂêë1„Éî„ÇØ„Çª„É´ÁßªÂãï
                    const offsets = [
                        [-1, -1], [0, -1], [1, -1],
                        [-1,  0],          [1,  0],
                        [-1,  1], [0,  1], [1,  1]
                    ];

                    shuffled.forEach(p => {
                        const offset = offsets[Math.floor(seededRandom(randomSeed++) * offsets.length)];
                        const newX = p.x + offset[0];
                        const newY = p.y + offset[1];

                        if (newX >= 0 && newX < w && newY >= 0 && newY < h) {
                            const oldIdx = (p.y * w + p.x) * 4;
                            const newIdx = (newY * w + newX) * 4;

                            // ÂÖÉ„ÅÆ‰ΩçÁΩÆ„ÇíËÉåÊôØËâ≤„ÅßÂ°ó„Çä„Å§„Å∂„Åó
                            frameData[oldIdx] = bgR;
                            frameData[oldIdx + 1] = bgG;
                            frameData[oldIdx + 2] = bgB;
                            if (transparent) frameData[oldIdx + 3] = 0;

                            // Êñ∞„Åó„ÅÑ‰ΩçÁΩÆ„Å´ÊèèÁîª
                            frameData[newIdx] = p.r;
                            frameData[newIdx + 1] = p.g;
                            frameData[newIdx + 2] = p.b;
                            frameData[newIdx + 3] = 255;
                        }
                    });
                }

                return new ImageData(frameData, w, h);
            }

            // 3„Éï„É¨„Éº„É†ÁîüÊàêÔºàÁï∞„Å™„ÇãÂÅè„ÇäÊñπ„Å®„Éé„Ç§„Ç∫ÈáèÔºâ
            return [
                createFrame(0.2, 'uniform', noisePercentages[0], noiseMode),      // „Éï„É¨„Éº„É†1
                createFrame(0.5, 'bottom-bias', noisePercentages[1], noiseMode),  // „Éï„É¨„Éº„É†2
                createFrame(0.8, 'top-bias', noisePercentages[2], noiseMode)      // „Éï„É¨„Éº„É†3
            ];
        }

        async function createGIF(frames, w, h, updateProgress) {
            return new Promise((resolve, reject) => {
                try {
                    if (typeof GIF === 'undefined') {
                        throw new Error('gif.js „ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
                    }

                    const gif = new GIF({
                        workers: 1,
                        quality: 10,
                        width: w,
                        height: h,
                        workerScript: './gif.worker.js'  // Âêå‰∏Ä„Ç™„É™„Ç∏„É≥
                    });

                    console.log('GIFË®≠ÂÆö:', { workers: 1, quality: 10, width: w, height: h, workerScript: './gif.worker.js' });

                    frames.forEach((frameData, index) => {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = w;
                        tempCanvas.height = h;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(frameData, 0, 0);

                        gif.addFrame(tempCanvas, { delay: 50 });
                        console.log(`„Éï„É¨„Éº„É† ${index + 1}/${frames.length} ËøΩÂä†ÂÆå‰∫Ü`);
                    });

                    gif.on('progress', (progress) => {
                        const percentage = 50 + Math.round(progress * 50);
                        console.log('GIFÁîüÊàêÈÄ≤Ë°å:', percentage + '%');
                        if (updateProgress) {
                            updateProgress(percentage, `GIFÂ§âÊèõ‰∏≠... ${percentage}%`);
                        }
                    });

                    gif.on('finished', blob => {
                        console.log('GIFÁîüÊàêÂÆå‰∫Ü:', blob.size, 'bytes');
                        if (updateProgress) {
                            updateProgress(100, 'ÂÆå‰∫ÜÔºÅ');
                        }
                        resolve(blob);
                    });

                    gif.on('error', err => {
                        console.error('GIFÁîüÊàê„Ç®„É©„Éº:', err);
                        reject(err);
                    });

                    console.log('GIF renderÈñãÂßã');
                    gif.render();
                } catch (err) {
                    console.error('GIFÁîüÊàêÂàùÊúüÂåñ„Ç®„É©„Éº:', err);
                    reject(err);
                }
            });
        }

        // ============================================
        // „Éù„Ç§„É≥„Çø„Éº„Ç§„Éô„É≥„Éà
        // ============================================

        canvas.addEventListener('pointerdown', (e) => {
            if (isSaveMode) return;

            e.preventDefault();
            canvas.setPointerCapture(e.pointerId);
            activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

            if (e.pointerType === 'pen') {
                pencilDetected = true;
            }

            if (activePointers.size === 1) {
                touchStartTime = Date.now();
                touchStartPos = { x: e.clientX, y: e.clientY };
                maxFingers = 1;
                isPinching = false;
                strokeMade = false;
            }
            maxFingers = Math.max(maxFingers, activePointers.size);

            // 2Êú¨Êåá = „Éî„É≥„ÉÅ/„Éë„É≥Ê∫ñÂÇô
            if (activePointers.size === 2) {
                isDrawing = false;
                isLassoing = false;
                lassoCanvas.style.display = 'none';
                isPinching = false;
                const pts = Array.from(activePointers.values());
                lastPinchDist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
                lastPinchCenter = {
                    x: (pts[0].x + pts[1].x) / 2,
                    y: (pts[0].y + pts[1].y) / 2
                };
                initialPinchDist = lastPinchDist;
                initialPinchCenter = { x: lastPinchCenter.x, y: lastPinchCenter.y };
                return;
            }

            const canDraw = e.pointerType === 'pen' || (e.pointerType === 'touch' && !pencilDetected);

            if (activePointers.size === 1 && canDraw) {
                const p = getCanvasPoint(e.clientX, e.clientY);

                if (currentTool === 'pen') {
                    isDrawing = true;
                    lastX = p.x;
                    lastY = p.y;
                    drawLine(p.x, p.y, p.x, p.y);
                } else if (currentTool === 'fill') {
                    // „Éê„Ç±„ÉÑ„ÉÑ„Éº„É´: „Çø„ÉÉ„Éó„ÅãÊäï„ÅíÁ∏Ñ„Åã„ÄÅpointerup„ÅßÂà§ÂÆö
                    startLasso(e.clientX, e.clientY);
                }
            }
        });

        canvas.addEventListener('pointermove', (e) => {
            if (!activePointers.has(e.pointerId)) return;
            if (isSaveMode) return;

            e.preventDefault();
            activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

            // 2Êú¨Êåá = „Éî„É≥„ÉÅ„Ç∫„Éº„É† / „Éë„É≥
            if (activePointers.size === 2) {
                const pts = Array.from(activePointers.values());
                const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
                const center = {
                    x: (pts[0].x + pts[1].x) / 2,
                    y: (pts[0].y + pts[1].y) / 2
                };

                const distDelta = Math.abs(dist - initialPinchDist);
                const centerDelta = Math.hypot(center.x - initialPinchCenter.x, center.y - initialPinchCenter.y);

                if (distDelta > 10 || centerDelta > 10) {
                    isPinching = true;
                }

                if (isPinching) {
                    const zoomFactor = dist / lastPinchDist;
                    const oldScale = scale;
                    scale = Math.max(0.1, Math.min(20, scale * zoomFactor));

                    translateX = center.x - (center.x - translateX) * (scale / oldScale);
                    translateY = center.y - (center.y - translateY) * (scale / oldScale);

                    translateX += center.x - lastPinchCenter.x;
                    translateY += center.y - lastPinchCenter.y;

                    applyTransform();
                }

                lastPinchDist = dist;
                lastPinchCenter = center;

                return;
            }

            // ÊèèÁîª
            if (isDrawing && activePointers.size === 1) {
                const p = getCanvasPoint(e.clientX, e.clientY);
                drawLine(lastX, lastY, p.x, p.y);
                lastX = p.x;
                lastY = p.y;
                strokeMade = true;
            }

            // Êäï„ÅíÁ∏Ñ
            if (isLassoing && activePointers.size === 1) {
                updateLasso(e.clientX, e.clientY);
                strokeMade = true;
            }
        });

        canvas.addEventListener('pointerup', (e) => {
            if (isSaveMode) return;

            e.preventDefault();

            // ÊèèÁîªÁµÇ‰∫Ü
            if (isDrawing) {
                saveState();
                strokeMade = true;
            }

            // Êäï„ÅíÁ∏ÑÁµÇ‰∫Ü
            if (isLassoing) {
                // ÁßªÂãïË∑ùÈõ¢„ÅßÂà§ÂÆö: Áü≠„ÅÑ = „Çø„ÉÉ„Éó„ÄÅÈï∑„ÅÑ = Êäï„ÅíÁ∏Ñ
                const startP = lassoPoints[0];
                const totalDist = lassoPoints.reduce((acc, p, i) => {
                    if (i === 0) return 0;
                    const prev = lassoPoints[i - 1];
                    return acc + Math.hypot(p.x - prev.x, p.y - prev.y);
                }, 0);

                if (totalDist < 20) {
                    // „Çø„ÉÉ„Éó = ÈÄöÂ∏∏„ÅÆÂ°ó„Çä„Å§„Å∂„Åó
                    const p = getCanvasPoint(startP.x, startP.y);
                    floodFill(p.x, p.y);
                    saveState();
                    strokeMade = true;
                } else {
                    // Êäï„ÅíÁ∏ÑÂ°ó„Çä„Å§„Å∂„Åó
                    if (finishLasso()) {
                        saveState();
                        strokeMade = true;
                    }
                }

                isLassoing = false;
                lassoPoints = [];
                lassoCanvas.style.display = 'none';
                lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
            }

            activePointers.delete(e.pointerId);

            // ÂÖ®ÊåáÈõ¢„Åó„ÅüÊôÇ„ÅÆ„Çø„ÉÉ„ÉóÂà§ÂÆö
            if (activePointers.size === 0) {
                const duration = Date.now() - touchStartTime;

                if (maxFingers >= 2 && duration < 400 && !isPinching && !strokeMade) {
                    if (maxFingers === 2) undo();
                    if (maxFingers === 3) redo();
                }

                maxFingers = 0;
                touchStartPos = null;
                strokeMade = false;
                isPinching = false;
            }

            isDrawing = false;
        });

        canvas.addEventListener('pointercancel', (e) => {
            activePointers.delete(e.pointerId);
            isDrawing = false;
            isLassoing = false;
            isPinching = false;
            lassoCanvas.style.display = 'none';
        });

        // ============================================
        // UI„Ç§„Éô„É≥„Éà
        // ============================================

        // „ÉÑ„Éº„É´Âàá„ÇäÊõø„Åà
        document.querySelectorAll('[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                currentTool = btn.dataset.tool;
                document.querySelectorAll('[data-tool]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        // Ëâ≤Âàá„ÇäÊõø„Åà
        document.getElementById('colorBtn').addEventListener('click', () => {
            currentColor = currentColor === 'black' ? 'white' : 'black';
            updateColorButton();

            // „Çµ„Ç§„Ç∫„ÇíËâ≤„Å´Âøú„Åò„Å¶Âæ©ÂÖÉ
            document.getElementById('brushSize').value = colorSizes[currentColor];
            document.getElementById('sizeDisplay').textContent = colorSizes[currentColor];
        });

        // „Éñ„É©„Ç∑„Çµ„Ç§„Ç∫
        document.getElementById('brushSize').addEventListener('input', (e) => {
            const size = parseInt(e.target.value);
            colorSizes[currentColor] = size;
            document.getElementById('sizeDisplay').textContent = size;
        });

        // „ÇØ„É™„Ç¢
        document.getElementById('clearBtn').addEventListener('click', () => {
            ctx.fillStyle = isDarkMode ? '#000' : '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveState();
        });

        // ÂèçËª¢
        document.getElementById('invertBtn').addEventListener('click', () => {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark');
            document.body.classList.toggle('light');

            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];
                data[i + 1] = 255 - data[i + 1];
                data[i + 2] = 255 - data[i + 2];
            }
            ctx.putImageData(imgData, 0, 0);

            updateColorButton();
            saveState();
        });

        // „Ç∫„Éº„É†„É™„Çª„ÉÉ„Éà
        document.getElementById('resetZoomBtn').addEventListener('click', () => {
            scale = 1;
            translateX = 0;
            translateY = 0;
            applyTransform();
        });

        // ============================================
        // „ÇØ„É¨„Ç∏„ÉÉ„ÉàÊ©üËÉΩ
        // ============================================

        document.getElementById('credit-btn').addEventListener('click', () => {
            document.getElementById('credit-modal').classList.add('visible');
        });

        document.getElementById('credit-close').addEventListener('click', () => {
            document.getElementById('credit-modal').classList.remove('visible');
        });

        // „É¢„Éº„ÉÄ„É´ËÉåÊôØ„ÇØ„É™„ÉÉ„ÇØ„ÅßÈñâ„Åò„Çã
        document.getElementById('credit-modal').addEventListener('click', (e) => {
            if (e.target.id === 'credit-modal') {
                document.getElementById('credit-modal').classList.remove('visible');
            }
        });

        // ============================================
        // ‰øùÂ≠òÊ©üËÉΩ
        // ============================================

        // Á∏¶Ê®™ÊØîÈÅ∏Êäû
        document.querySelectorAll('[data-aspect]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-aspect]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedAspect = btn.dataset.aspect;
            });
        });

        // ÂÄçÁéáÈÅ∏Êäû
        document.querySelectorAll('[data-scale]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-scale]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedScale = parseInt(btn.dataset.scale);
            });
        });

        // „Éé„Ç§„Ç∫Âº∑Â∫¶ÈÅ∏Êäû
        document.querySelectorAll('[data-noise]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-noise]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedNoise = parseInt(btn.dataset.noise);
            });
        });

        // ËÉåÊôØÈÄèÈÅé„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆÂ§âÊõ¥Áõ£Ë¶ñ
        document.getElementById('transparentBg').addEventListener('change', (e) => {
            const isTransparent = e.target.checked;
            const noiseButtons = document.querySelectorAll('[data-noise]');

            if (isTransparent) {
                // ËÉåÊôØÈÄèÈÅéON: „Éé„Ç§„Ç∫1/2/3„ÇíÁÑ°ÂäπÂåñ
                noiseButtons.forEach(btn => {
                    const noiseValue = parseInt(btn.dataset.noise);
                    if (noiseValue > 0) {
                        btn.classList.add('disabled');
                    }
                });

                // ÁèæÂú®„ÅÆÈÅ∏Êäû„Åå„Éé„Ç§„Ç∫1/2/3„ÅÆÂ†¥Âêà„ÄÅËá™ÂãïÁöÑ„Å´„Éé„Ç§„Ç∫0„Å´Âàá„ÇäÊõø„Åà
                if (selectedNoise > 0) {
                    selectedNoise = 0;
                    noiseButtons.forEach(b => b.classList.remove('active'));
                    document.querySelector('[data-noise="0"]').classList.add('active');
                }
            } else {
                // ËÉåÊôØÈÄèÈÅéOFF: „Åô„Åπ„Å¶„ÅÆ„Éé„Ç§„Ç∫„Éú„Çø„É≥„ÇíÊúâÂäπÂåñ
                noiseButtons.forEach(btn => {
                    btn.classList.remove('disabled');
                });
            }
        });

        document.getElementById('saveBtn').addEventListener('click', () => {
            isSaveMode = true;
            document.getElementById('save-overlay').style.display = 'block';
            document.getElementById('save-ui').style.display = 'block';
            document.getElementById('selection-canvas').style.display = 'block';
            document.getElementById('toolbar-left').style.display = 'none';
            document.getElementById('toolbar-right').style.display = 'none';
            document.getElementById('resetZoomBtn').style.display = 'none';
        });

        function exitSaveMode() {
            isSaveMode = false;
            document.getElementById('save-overlay').style.display = 'none';
            document.getElementById('save-ui').style.display = 'none';
            document.getElementById('save-ui').classList.remove('hidden-during-selection');
            document.getElementById('save-ui').classList.remove('in-confirmation-mode');
            document.getElementById('selection-canvas').style.display = 'none';
            document.getElementById('generating').style.display = 'none';
            document.getElementById('toolbar-left').style.display = 'flex';
            document.getElementById('toolbar-right').style.display = 'flex';
            document.getElementById('resetZoomBtn').style.display = '';  // „Ç§„É≥„É©„Ç§„É≥„Çπ„Çø„Ç§„É´„Çí„ÇØ„É™„Ç¢
            document.getElementById('confirmSelectionBtn').style.display = 'none';
            document.getElementById('redoSelectionBtn').style.display = 'none';
            applyTransform();

            const selCanvas = document.getElementById('selection-canvas');
            const selCtx = selCanvas.getContext('2d');
            selCtx.clearRect(0, 0, selCanvas.width, selCanvas.height);

            selectionStart = null;
            selectionEnd = null;
            confirmedSelection = null;
        }

        document.getElementById('cancelSaveBtn').addEventListener('click', exitSaveMode);

        document.getElementById('saveAllBtn').addEventListener('click', () => {
            saveRegion(0, 0, canvas.width, canvas.height);
        });

        document.getElementById('confirmSelectionBtn').addEventListener('click', () => {
            if (confirmedSelection) {
                saveRegion(confirmedSelection.x, confirmedSelection.y, confirmedSelection.w, confirmedSelection.h);
            }
        });

        document.getElementById('redoSelectionBtn').addEventListener('click', () => {
            // ÈÅ∏ÊäûÁØÑÂõ≤„Çí„ÇØ„É™„Ç¢
            confirmedSelection = null;

            // Á¢∫ÂÆö„É¢„Éº„Éâ„ÇíËß£Èô§
            document.getElementById('save-ui').classList.remove('in-confirmation-mode');

            // „Éú„Çø„É≥„ÇíÈùûË°®Á§∫
            document.getElementById('confirmSelectionBtn').style.display = 'none';
            document.getElementById('redoSelectionBtn').style.display = 'none';

            // ÈÅ∏ÊäûÁü©ÂΩ¢„Çí„ÇØ„É™„Ç¢
            const selCanvas = document.getElementById('selection-canvas');
            const selCtx = selCanvas.getContext('2d');
            selCtx.clearRect(0, 0, selCanvas.width, selCanvas.height);
        });

        const overlay = document.getElementById('save-overlay');

        overlay.addEventListener('pointerdown', (e) => {
            if (!isSaveMode) return;
            selectionStart = { x: e.clientX, y: e.clientY };
            selectionEnd = { x: e.clientX, y: e.clientY };

            // ÁØÑÂõ≤ÈÅ∏ÊäûÈñãÂßãÊôÇ„Å´„É¢„Éº„ÉÄ„É´„ÇíÈùûË°®Á§∫
            document.getElementById('save-ui').classList.add('hidden-during-selection');
        });

        overlay.addEventListener('pointermove', (e) => {
            if (!isSaveMode || !selectionStart) return;
            selectionEnd = { x: e.clientX, y: e.clientY };

            const selCanvas = document.getElementById('selection-canvas');
            const selCtx = selCanvas.getContext('2d');
            selCtx.clearRect(0, 0, selCanvas.width, selCanvas.height);

            // Á∏¶Ê®™ÊØî„Å´Âü∫„Å•„ÅÑ„Å¶Áü©ÂΩ¢„ÇíË™øÊï¥
            let rectX = selectionStart.x;
            let rectY = selectionStart.y;
            let rectW = selectionEnd.x - selectionStart.x;
            let rectH = selectionEnd.y - selectionStart.y;

            if (selectedAspect !== 'free') {
                const aspectRatios = {
                    '1:1': 1 / 1,
                    '4:5': 4 / 5,
                    '16:9': 16 / 9,
                    '9:16': 9 / 16
                };
                const ratio = aspectRatios[selectedAspect];

                // Á¨¶Âè∑„Çí‰øùÂ≠ò
                const signW = rectW < 0 ? -1 : 1;
                const signH = rectH < 0 ? -1 : 1;

                // ÂπÖ„Å®È´ò„Åï„ÅÆÁü≠„ÅÑÊñπ„ÇíÂü∫Ê∫ñ„Å´„Åó„Å¶Á∏¶Ê®™ÊØî„ÇíÁ∂≠ÊåÅ
                if (Math.abs(rectW) / Math.abs(rectH) > ratio) {
                    // ÂπÖ„ÅåÈï∑„Åô„Åé„Çã ‚Üí È´ò„Åï„Å´Âêà„Çè„Åõ„Çã
                    rectW = Math.abs(rectH) * ratio * signW;
                } else {
                    // È´ò„Åï„ÅåÈï∑„Åô„Åé„Çã ‚Üí ÂπÖ„Å´Âêà„Çè„Åõ„Çã
                    rectH = Math.abs(rectW) / ratio * signH;
                }
            }

            selCtx.strokeStyle = isDarkMode ? '#fff' : '#000';
            selCtx.lineWidth = 2;
            selCtx.setLineDash([8, 8]);
            selCtx.strokeRect(rectX, rectY, rectW, rectH);
        });

        overlay.addEventListener('pointerup', (e) => {
            if (!isSaveMode || !selectionStart) return;

            // Á∏¶Ê®™ÊØî„Å´Âü∫„Å•„ÅÑ„Å¶Áü©ÂΩ¢„ÇíË™øÊï¥Ôºàpointermove„Å®Âêå„Åò„É≠„Ç∏„ÉÉ„ÇØÔºâ
            let rectX = selectionStart.x;
            let rectY = selectionStart.y;
            let rectW = selectionEnd.x - selectionStart.x;
            let rectH = selectionEnd.y - selectionStart.y;

            if (selectedAspect !== 'free') {
                const aspectRatios = {
                    '1:1': 1 / 1,
                    '4:5': 4 / 5,
                    '16:9': 16 / 9,
                    '9:16': 9 / 16
                };
                const ratio = aspectRatios[selectedAspect];

                // Á¨¶Âè∑„Çí‰øùÂ≠ò
                const signW = rectW < 0 ? -1 : 1;
                const signH = rectH < 0 ? -1 : 1;

                if (Math.abs(rectW) / Math.abs(rectH) > ratio) {
                    rectW = Math.abs(rectH) * ratio * signW;
                } else {
                    rectH = Math.abs(rectW) / ratio * signH;
                }
            }

            const x1 = Math.floor((Math.min(rectX, rectX + rectW) - translateX) / scale);
            const y1 = Math.floor((Math.min(rectY, rectY + rectH) - translateY) / scale);
            const x2 = Math.floor((Math.max(rectX, rectX + rectW) - translateX) / scale);
            const y2 = Math.floor((Math.max(rectY, rectY + rectH) - translateY) / scale);

            const w = x2 - x1;
            const h = y2 - y1;

            if (w > 5 && h > 5) {
                const cx = Math.max(0, Math.min(x1, canvas.width));
                const cy = Math.max(0, Math.min(y1, canvas.height));
                const cw = Math.min(w, canvas.width - cx);
                const ch = Math.min(h, canvas.height - cy);

                if (cw > 0 && ch > 0) {
                    // ÈÅ∏ÊäûÁØÑÂõ≤„ÇíÁ¢∫ÂÆöÔºà‰øùÂ≠ò„ÅØ„Åó„Å™„ÅÑÔºâ
                    confirmedSelection = { x: cx, y: cy, w: cw, h: ch };

                    // Á¢∫ÂÆö„É¢„Éº„Éâ„Å´ÂÖ•„Çã
                    document.getElementById('save-ui').classList.add('in-confirmation-mode');
                    document.getElementById('save-ui').classList.remove('hidden-during-selection');

                    // Á¢∫ÂÆö„Éª„ÇÑ„ÇäÁõ¥„Åó„Éú„Çø„É≥„ÇíË°®Á§∫
                    document.getElementById('confirmSelectionBtn').style.display = 'inline-block';
                    document.getElementById('redoSelectionBtn').style.display = 'inline-block';
                }
            }

            selectionStart = null;
            selectionEnd = null;
        });

        async function saveRegion(x, y, w, h) {
            const transparent = document.getElementById('transparentBg').checked;
            const noiseLevel = selectedNoise;  // 0, 1, 2, 3
            const outputScale = selectedScale;  // 1, 2, 3

            const flash = document.getElementById('flash');
            flash.style.opacity = '0.7';
            setTimeout(() => { flash.style.opacity = '0'; }, 100);

            let blob, fileName;

            try {
                if (noiseLevel > 0) {
                    // GIFÁîüÊàê
                    document.getElementById('generating').style.display = 'block';

                    // „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„Çí„É™„Çª„ÉÉ„Éà
                    const progressFill = document.getElementById('progress-fill');
                    const progressText = document.getElementById('progress-text');

                    function updateProgress(percent, text) {
                        if (progressFill) progressFill.style.width = percent + '%';
                        if (progressText) progressText.textContent = text;
                    }

                    console.log('GIF‰øùÂ≠òÈñãÂßã:', { x, y, w, h, transparent });

                    updateProgress(0, 'Ê∫ñÂÇô‰∏≠...');
                    await new Promise(resolve => setTimeout(resolve, 100)); // UIÊõ¥Êñ∞„ÇíÂæÖ„Å§

                    updateProgress(10, 'ÁîªÂÉè„Éá„Éº„ÇøË™≠„ÅøËæº„Åø‰∏≠...');
                    const imgData = ctx.getImageData(x, y, w, h);
                    console.log('ÁîªÂÉè„Éá„Éº„ÇøÂèñÂæó:', imgData.width, 'x', imgData.height);
                    await new Promise(resolve => setTimeout(resolve, 50));

                    // ËÉåÊôØÈÄèÈÅéÂá¶ÁêÜ
                    if (transparent) {
                        updateProgress(20, 'ËÉåÊôØÈÄèÈÅéÂá¶ÁêÜ‰∏≠...');
                        const data = imgData.data;
                        const bgR = isDarkMode ? 0 : 255;
                        const bgG = isDarkMode ? 0 : 255;
                        const bgB = isDarkMode ? 0 : 255;

                        for (let i = 0; i < data.length; i += 4) {
                            if (data[i] === bgR && data[i + 1] === bgG && data[i + 2] === bgB) {
                                data[i + 3] = 0;
                            }
                        }
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }

                    updateProgress(30, '„Ç∞„É™„ÉÉ„ÉÅ„Éï„É¨„Éº„É†ÁîüÊàê‰∏≠...');
                    await new Promise(resolve => setTimeout(resolve, 50));

                    const frames = generateGlitchFrames(imgData, transparent, noiseLevel);
                    console.log('„Ç∞„É™„ÉÉ„ÉÅ„Éï„É¨„Éº„É†ÁîüÊàêÂÆå‰∫Ü:', frames.length, '„Éï„É¨„Éº„É†');

                    updateProgress(50, 'GIFÂ§âÊèõ‰∏≠...');

                    // ÂÄçÁéá„ÇíÈÅ©Áî®„Åó„ÅüÂá∫Âäõ„Çµ„Ç§„Ç∫
                    const outputW = w * outputScale;
                    const outputH = h * outputScale;

                    // „Éï„É¨„Éº„É†„ÇíÊã°Â§ß
                    const scaledFrames = frames.map(frameData => {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = w;
                        tempCanvas.height = h;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(frameData, 0, 0);

                        const scaledCanvas = document.createElement('canvas');
                        scaledCanvas.width = outputW;
                        scaledCanvas.height = outputH;
                        const scaledCtx = scaledCanvas.getContext('2d');
                        scaledCtx.imageSmoothingEnabled = false;  // „Éî„ÇØ„Çª„É´ÊÑü„ÇíÁ∂≠ÊåÅ
                        scaledCtx.drawImage(tempCanvas, 0, 0, outputW, outputH);

                        return scaledCtx.getImageData(0, 0, outputW, outputH);
                    });

                    blob = await createGIF(scaledFrames, outputW, outputH, updateProgress);
                    fileName = `desu_${Date.now()}.gif`;
                    console.log('GIFÁîüÊàêÂÆå‰∫Ü');

                    document.getElementById('generating').style.display = 'none';
                } else {
                    // PNGÁîüÊàêÔºà„Éé„Ç§„Ç∫0„ÅÆÈùôÊ≠¢ÁîªÔºâ
                    const outputW = w * outputScale;
                    const outputH = h * outputScale;

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = outputW;
                    tempCanvas.height = outputH;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.imageSmoothingEnabled = false;  // „Éî„ÇØ„Çª„É´ÊÑü„ÇíÁ∂≠ÊåÅ

                    if (transparent) {
                        const imgData = ctx.getImageData(x, y, w, h);
                        const data = imgData.data;
                        const bgR = isDarkMode ? 0 : 255;
                        const bgG = isDarkMode ? 0 : 255;
                        const bgB = isDarkMode ? 0 : 255;

                        for (let i = 0; i < data.length; i += 4) {
                            if (data[i] === bgR && data[i + 1] === bgG && data[i + 2] === bgB) {
                                data[i + 3] = 0;
                            }
                        }

                        // Êã°Â§ß„Åó„Å¶ÊèèÁîª
                        const sourceCanvas = document.createElement('canvas');
                        sourceCanvas.width = w;
                        sourceCanvas.height = h;
                        sourceCanvas.getContext('2d').putImageData(imgData, 0, 0);
                        tempCtx.drawImage(sourceCanvas, 0, 0, outputW, outputH);
                    } else {
                        tempCtx.drawImage(canvas, x, y, w, h, 0, 0, outputW, outputH);
                    }

                    blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png'));
                    fileName = `desu_${Date.now()}.png`;
                }

                // iOS SafariÂØæÂøúÔºödownloadÂ±ûÊÄß„Åß„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                // iOSÂêë„Åë: navigator.share„ÇÇË©¶„Åø„ÇãÔºàGIF‰øùÂ≠òÊàêÂäüÁéáÂêë‰∏äÔºâ
                if (navigator.share && /iPad|iPhone|iPod/.test(navigator.userAgent)) {
                    try {
                        const file = new File([blob], fileName, { type: blob.type });
                        if (navigator.canShare && navigator.canShare({ files: [file] })) {
                            // share„Éú„Çø„É≥„ÇíË°®Á§∫„Åô„Çã„Åã„ÄÅ„É¶„Éº„Ç∂„Éº„Å´ÈÅ∏ÊäûËÇ¢„ÇíÊèê‰æõ
                            setTimeout(async () => {
                                const shouldShare = confirm('ÂÖ±Êúâ„É°„Éã„É•„Éº„Åã„Çâ‰øùÂ≠ò„Åó„Åæ„Åô„ÅãÔºü\nÔºàGIF„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅåÁ¢∫ÂÆü„Å´‰øùÂ≠ò„Åï„Çå„Åæ„ÅôÔºâ');
                                if (shouldShare) {
                                    await navigator.share({
                                        files: [file],
                                        title: 'DESU‚Ñ¢ PAINT',
                                        text: fileName
                                    });
                                }
                            }, 500);
                        }
                    } catch (err) {
                        console.log('Share APIÂà©Áî®‰∏çÂèØ:', err);
                    }
                }

                setTimeout(() => URL.revokeObjectURL(url), 1000);

                exitSaveMode();
            } catch (err) {
                console.error('‰øùÂ≠ò„Ç®„É©„Éº:', err);
                document.getElementById('generating').style.display = 'none';

                const progressText = document.getElementById('progress-text');
                if (progressText) {
                    progressText.textContent = '„Ç®„É©„Éº: ' + err.message;
                }

                setTimeout(() => {
                    alert('‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Ç≥„É≥„ÇΩ„Éº„É´„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n„Ç®„É©„Éº: ' + err.message);
                    exitSaveMode();
                }, 500);
            }
        }

        // ============================================
        // ÁîªÈù¢ÂõûËª¢ÂØæÂøú
        // ============================================

        window.addEventListener('orientationchange', () => {
            setTimeout(async () => {
                const bitmap = await createImageBitmap(canvas);

                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                lassoCanvas.width = window.innerWidth;
                lassoCanvas.height = window.innerHeight;

                ctx.fillStyle = isDarkMode ? '#000' : '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(bitmap, 0, 0);
                bitmap.close();

                const selCanvas = document.getElementById('selection-canvas');
                selCanvas.width = window.innerWidth;
                selCanvas.height = window.innerHeight;

                applyTransform();
            }, 100);
        });

        // ============================================
        // Ëµ∑Âãï
        // ============================================

        initCanvas();
    </script>
</body>
</html>
