<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>DESU‚Ñ¢ Paint</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            background: #1a1a1a;
        }

        body.light {
            background: #e0e0e0;
        }

        #canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: pixelated;
            image-rendering: -webkit-optimize-contrast;
            touch-action: none;
            transform-origin: 0 0;
        }

        /* Êäï„ÅíÁ∏ÑÁî®„Ç™„Éº„Éê„Éº„É¨„Ç§„Ç≠„É£„É≥„Éê„Çπ */
        #lasso-canvas {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 50;
        }

        /* Â∑¶‰∏ã„ÉÑ„Éº„É´„Éê„Éº */
        #toolbar-left {
            position: fixed;
            left: 12px;
            bottom: 120px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        /* Âè≥‰∏ä„ÉÑ„Éº„É´„Éê„Éº */
        #toolbar-right {
            position: fixed;
            top: max(12px, env(safe-area-inset-top));
            right: 12px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .tool-btn {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            border: 2px solid #666;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            cursor: pointer;
            transition: transform 0.1s, background 0.1s;
            color: #333;
        }

        .tool-btn svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .tool-btn svg .filled {
            fill: currentColor;
            stroke: none;
        }

        body.dark .tool-btn {
            background: rgba(40, 40, 40, 0.9);
            border-color: #888;
            color: #fff;
        }

        .tool-btn:active {
            transform: scale(0.92);
        }

        .tool-btn.active {
            background: #333;
            border-color: #fff;
            color: #fff;
        }

        body.dark .tool-btn.active {
            background: #fff;
            border-color: #333;
            color: #333;
        }

        /* Á∏¶„Çπ„É©„Ç§„ÉÄ„Éº */
        #size-slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            margin-top: 8px;
            width: 48px;
        }

        #brushSize {
            -webkit-appearance: none;
            appearance: none;
            width: 100px;
            height: 6px;
            background: #888;
            border-radius: 3px;
            transform: rotate(-90deg);
            transform-origin: center center;
            margin: 47px 0;
        }

        body.dark #brushSize {
            background: #888;
        }

        #brushSize::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #333;
            border-radius: 50%;
            border: 2px solid #fff;
        }

        body.dark #brushSize::-webkit-slider-thumb {
            background: #fff;
            border-color: #333;
        }

        #sizeDisplay {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 4px 8px;
            border-radius: 6px;
            min-width: 32px;
            text-align: center;
        }

        body.dark #sizeDisplay {
            color: #fff;
            background: rgba(40, 40, 40, 0.9);
        }

        /* „Ç∫„Éº„É†„É™„Çª„ÉÉ„Éà„Éú„Çø„É≥Ôºà„Ç∫„Éº„É†‰∏≠„ÅÆ„ÅøË°®Á§∫Ôºâ */
        #resetZoomBtn {
            display: none;
            position: fixed;
            bottom: max(20px, calc(env(safe-area-inset-bottom) + 12px));
            right: max(20px, calc(env(safe-area-inset-right) + 12px));
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 2px solid #666;
            background: rgba(255, 255, 255, 0.9);
            z-index: 100;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #333;
        }

        #resetZoomBtn svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        body.dark #resetZoomBtn {
            background: rgba(40, 40, 40, 0.9);
            border-color: #888;
            color: #fff;
        }

        #resetZoomBtn.visible {
            display: flex;
        }

        /* ‰øùÂ≠ò„É¢„Éº„ÉÄ„É´ */
        #save-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 200;
        }

        #save-ui {
            display: none;
            position: fixed;
            top: max(12px, env(safe-area-inset-top));
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 16px 24px;
            border-radius: 12px;
            z-index: 201;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        body.dark #save-ui {
            background: rgba(30, 30, 30, 0.95);
            color: #fff;
        }

        #save-ui h3 {
            font-size: 14px;
            margin-bottom: 12px;
            font-weight: normal;
            color: #666;
        }

        body.dark #save-ui h3 {
            color: #aaa;
        }

        #save-ui label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            margin-bottom: 12px;
        }

        #save-ui input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        .save-btn {
            padding: 10px 20px;
            margin: 0 4px;
            border: 1px solid #333;
            background: #fff;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
        }

        body.dark .save-btn {
            background: #444;
            border-color: #888;
            color: #fff;
        }

        .save-btn:active {
            transform: scale(0.96);
        }

        .save-btn.primary {
            background: #333;
            color: #fff;
        }

        body.dark .save-btn.primary {
            background: #fff;
            color: #333;
        }

        /* ÈÅ∏ÊäûÁØÑÂõ≤„Ç≠„É£„É≥„Éê„Çπ */
        #selection-canvas {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 199;
        }

        /* „Éï„É©„ÉÉ„Ç∑„É•„Ç®„Éï„Çß„ÇØ„Éà */
        #flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            opacity: 0;
            pointer-events: none;
            z-index: 300;
            transition: opacity 0.1s;
        }

        /* ÁîüÊàê‰∏≠„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº */
        #generating {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 24px 48px;
            border-radius: 16px;
            z-index: 250;
            font-size: 16px;
            min-width: 280px;
            text-align: center;
        }

        #progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin-top: 16px;
            overflow: hidden;
            position: relative;
        }

        #progress-fill {
            height: 100%;
            background: #fff;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        #progress-text {
            margin-top: 8px;
            font-size: 13px;
            opacity: 0.8;
        }

        /* „Çπ„Éî„Éä„Éº„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: -4px;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞Ë°®Á§∫ */
        #debug-log {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            max-height: 200px;
            background: rgba(0, 0, 0, 0.95);
            color: #0f0;
            font-family: monospace;
            font-size: 11px;
            padding: 8px;
            overflow-y: auto;
            z-index: 999;
            border-top: 2px solid #0f0;
        }

        #debug-log.visible {
            display: block;
        }

        #debug-log div {
            margin: 2px 0;
            word-wrap: break-word;
        }

        #debug-toggle {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 0, 0.3);
            border: 2px solid #0f0;
            border-radius: 50%;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
        }
    </style>
</head>
<body class="light">
    <canvas id="canvas"></canvas>
    <canvas id="lasso-canvas"></canvas>

    <!-- Â∑¶‰∏ã„ÉÑ„Éº„É´„Éê„Éº -->
    <div id="toolbar-left">
        <div class="tool-btn active" id="penBtn" data-tool="pen">
            <svg viewBox="0 0 24 24">
                <path d="M4 18 Q8 8 12 12 Q16 16 20 6" fill="none"/>
            </svg>
        </div>
        <div class="tool-btn" id="fillBtn" data-tool="fill">
            <svg viewBox="0 0 24 24">
                <path d="M6 8 L10 4 L18 12 L14 16 Z" class="filled"/>
                <path d="M16 16 Q18 18 17 21 Q16 24 15 21 Q14 18 16 16 Z" class="filled"/>
            </svg>
        </div>
        <div class="tool-btn" id="colorBtn">
            <svg viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="8" id="colorCircle" class="filled"/>
            </svg>
        </div>
        <div id="size-slider-container">
            <input type="range" id="brushSize" min="1" max="20" value="1">
            <span id="sizeDisplay">1</span>
        </div>
    </div>

    <!-- Âè≥‰∏ä„ÉÑ„Éº„É´„Éê„Éº -->
    <div id="toolbar-right">
        <div class="tool-btn" id="saveBtn">
            <svg viewBox="0 0 24 24">
                <path d="M12 4 L12 16 M6 12 L12 18 L18 12"/>
                <path d="M4 20 L20 20"/>
            </svg>
        </div>
        <div class="tool-btn" id="clearBtn">
            <svg viewBox="0 0 24 24">
                <path d="M12 4 L12 2 M12 22 L12 20 M4 12 L2 12 M22 12 L20 12 M6.34 6.34 L4.93 4.93 M19.07 19.07 L17.66 17.66 M6.34 17.66 L4.93 19.07 M19.07 4.93 L17.66 6.34"/>
            </svg>
        </div>
        <div class="tool-btn" id="invertBtn">
            <svg viewBox="0 0 24 24">
                <path d="M12 4 A8 8 0 0 0 12 20 Z"/>
                <path d="M12 4 A8 8 0 0 1 12 20 Z" class="filled"/>
            </svg>
        </div>
    </div>

    <!-- „Ç∫„Éº„É†„É™„Çª„ÉÉ„Éà„Éú„Çø„É≥ -->
    <div id="resetZoomBtn">
        <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="8"/>
            <path d="M12 7 L12 17 M7 12 L17 12"/>
        </svg>
    </div>

    <!-- ‰øùÂ≠òUI -->
    <div id="save-overlay"></div>
    <div id="save-ui">
        <h3>ÁØÑÂõ≤„Çí„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶ÈÅ∏Êäû</h3>
        <label>
            <input type="checkbox" id="transparentBg">
            ËÉåÊôØÈÄèÈÅé
        </label>
        <label>
            <input type="checkbox" id="glitchMode" checked>
            üíÄ
        </label>
        <div>
            <button class="save-btn primary" id="saveAllBtn">ÂÖ®‰Ωì„Çí‰øùÂ≠ò</button>
            <button class="save-btn" id="cancelSaveBtn">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <canvas id="selection-canvas"></canvas>
    <div id="flash"></div>
    <div id="generating">
        <div><span class="spinner"></span>GIFÁîüÊàê‰∏≠...</div>
        <div id="progress-bar">
            <div id="progress-fill"></div>
        </div>
        <div id="progress-text">Ê∫ñÂÇô‰∏≠...</div>
    </div>

    <!-- „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞ -->
    <div id="debug-toggle">üêõ</div>
    <div id="debug-log"></div>

    <!-- gif.js CDN -->
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>

    <script>
        // ============================================
        // DESU‚Ñ¢ Paint - iPadÂ∞ÇÁî®Áâà v4 (GIFÊåØÂãïÊ©üËÉΩËøΩÂä†)
        // ============================================

        // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞Ê©üËÉΩ
        const debugLog = document.getElementById('debug-log');
        const debugToggle = document.getElementById('debug-toggle');
        let debugVisible = false;

        debugToggle.addEventListener('click', () => {
            debugVisible = !debugVisible;
            if (debugVisible) {
                debugLog.classList.add('visible');
            } else {
                debugLog.classList.remove('visible');
            }
        });

        // ÂÖÉ„ÅÆconsole.log„Å®console.error„Çí‰øùÂ≠ò
        const originalLog = console.log;
        const originalError = console.error;

        function addToDebugLog(message, isError = false) {
            const div = document.createElement('div');
            if (isError) {
                div.style.color = '#f00';
            }
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            debugLog.appendChild(div);
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        // console.log„Çí‰∏äÊõ∏„Åç
        console.log = function(...args) {
            originalLog.apply(console, args);
            const message = args.map(arg =>
                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
            ).join(' ');
            addToDebugLog(message, false);
        };

        // console.error„Çí‰∏äÊõ∏„Åç
        console.error = function(...args) {
            originalError.apply(console, args);
            const message = 'ERROR: ' + args.map(arg =>
                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
            ).join(' ');
            addToDebugLog(message, true);
        };

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const lassoCanvas = document.getElementById('lasso-canvas');
        const lassoCtx = lassoCanvas.getContext('2d');

        // --- Áä∂ÊÖã ---
        let isDarkMode = false;
        let currentTool = 'pen';  // 'pen' or 'fill'
        let currentColor = 'black';  // 'black' or 'white'
        let isDrawing = false;
        let lastX = 0, lastY = 0;

        // „Ç∫„Éº„É†/„Éë„É≥
        let scale = 1;
        let translateX = 0, translateY = 0;

        // Ëâ≤„Åî„Å®„ÅÆ„Éñ„É©„Ç∑„Çµ„Ç§„Ç∫‰øùÊåÅ
        const colorSizes = { black: 1, white: 5 };

        // undo/redoÁî®ÔºàImageBitmapÊñπÂºèÔºâ
        let undoStack = [];
        let redoStack = [];
        const MAX_HISTORY = 15;

        // „Éù„Ç§„É≥„Çø„ÉºÁÆ°ÁêÜ
        let activePointers = new Map();
        let pencilDetected = false;

        // „Çø„ÉÉ„ÉóÂà§ÂÆöÁî®
        let touchStartTime = 0;
        let touchStartPos = null;
        let maxFingers = 0;
        let strokeMade = false;

        // „Éî„É≥„ÉÅÁî®
        let lastPinchDist = 0;
        let lastPinchCenter = { x: 0, y: 0 };
        let initialPinchDist = 0;
        let initialPinchCenter = { x: 0, y: 0 };
        let isPinching = false;

        // Êäï„ÅíÁ∏ÑÁî®
        let lassoPoints = [];
        let isLassoing = false;

        // ‰øùÂ≠ò„É¢„Éº„Éâ
        let isSaveMode = false;
        let selectionStart = null;
        let selectionEnd = null;

        // ============================================
        // ÂàùÊúüÂåñ
        // ============================================

        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            lassoCanvas.width = window.innerWidth;
            lassoCanvas.height = window.innerHeight;

            const selCanvas = document.getElementById('selection-canvas');
            selCanvas.width = window.innerWidth;
            selCanvas.height = window.innerHeight;

            applyTransform();
            updateColorButton();
            saveState();
        }

        function applyTransform() {
            canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;

            const resetBtn = document.getElementById('resetZoomBtn');
            if (Math.abs(scale - 1) > 0.01 || Math.abs(translateX) > 1 || Math.abs(translateY) > 1) {
                resetBtn.classList.add('visible');
            } else {
                resetBtn.classList.remove('visible');
            }
        }

        function getCanvasPoint(clientX, clientY) {
            return {
                x: Math.floor((clientX - translateX) / scale),
                y: Math.floor((clientY - translateY) / scale)
            };
        }

        // ÁèæÂú®„ÅÆÊèèÁîªËâ≤„ÇíÂèñÂæó
        function getDrawColor() {
            if (currentColor === 'black') {
                return isDarkMode ? '#fff' : '#000';
            } else {
                return isDarkMode ? '#000' : '#fff';
            }
        }

        // Ëâ≤„Éú„Çø„É≥„ÅÆË°®Á§∫Êõ¥Êñ∞
        function updateColorButton() {
            const circle = document.getElementById('colorCircle');

            // ÈªíÈÅ∏ÊäûÊôÇ„ÅØÂ°ó„Çä„Å§„Å∂„Åó„ÄÅÁôΩÈÅ∏ÊäûÊôÇ„ÅØÁôΩÊäú„ÅçÔºà„Çπ„Éà„É≠„Éº„ÇØ„ÅÆ„ÅøÔºâ
            if (currentColor === 'black') {
                circle.classList.add('filled');
                circle.style.stroke = 'none';
            } else {
                circle.classList.remove('filled');
                circle.style.stroke = 'currentColor';
                circle.style.strokeWidth = '2';
            }
        }

        // ============================================
        // ÊèèÁîª„Ç®„É≥„Ç∏„É≥Ôºà2ÂÄ§„Éª„Éñ„É¨„Çº„É≥„Éè„É†Ôºâ
        // ============================================

        function drawLine(x1, y1, x2, y2) {
            const size = colorSizes[currentColor];
            ctx.fillStyle = getDrawColor();

            const r = Math.floor(size / 2);
            let dx = Math.abs(x2 - x1), sx = x1 < x2 ? 1 : -1;
            let dy = -Math.abs(y2 - y1), sy = y1 < y2 ? 1 : -1;
            let err = dx + dy;

            while (true) {
                if (size === 1) {
                    ctx.fillRect(x1, y1, 1, 1);
                } else {
                    ctx.fillRect(x1 - r, y1 - r, size, size);
                }

                if (x1 === x2 && y1 === y2) break;
                const e2 = 2 * err;
                if (e2 >= dy) { err += dy; x1 += sx; }
                if (e2 <= dx) { err += dx; y1 += sy; }
            }
        }

        // ============================================
        // Â°ó„Çä„Å§„Å∂„ÅóÔºà„Çπ„Ç≠„É£„É≥„É©„Ç§„É≥Ê≥ïÔºâ
        // ============================================

        function floodFill(startX, startY) {
            const w = canvas.width, h = canvas.height;

            if (startX < 0 || startX >= w || startY < 0 || startY >= h) return;

            const imgData = ctx.getImageData(0, 0, w, h);
            const data = imgData.data;

            const idx = (startY * w + startX) * 4;
            const targetR = data[idx], targetG = data[idx + 1], targetB = data[idx + 2];

            // Â°ó„Çä„Å§„Å∂„ÅóËâ≤„ÇíÊ±∫ÂÆö
            const fillColorHex = getDrawColor();
            const fillColor = fillColorHex === '#fff' || fillColorHex === '#FFF'
                ? [255, 255, 255]
                : [0, 0, 0];

            if (targetR === fillColor[0] && targetG === fillColor[1] && targetB === fillColor[2]) return;

            const matchTarget = (i) => data[i] === targetR && data[i + 1] === targetG && data[i + 2] === targetB;
            const setPixel = (i) => {
                data[i] = fillColor[0];
                data[i + 1] = fillColor[1];
                data[i + 2] = fillColor[2];
                data[i + 3] = 255;
            };

            const stack = [[startX, startY]];

            while (stack.length > 0) {
                let [x, y] = stack.pop();
                let i = (y * w + x) * 4;

                while (x >= 0 && matchTarget(i)) {
                    x--;
                    i -= 4;
                }
                x++;
                i += 4;

                let spanAbove = false, spanBelow = false;

                while (x < w && matchTarget(i)) {
                    setPixel(i);

                    if (y > 0) {
                        const above = i - w * 4;
                        if (matchTarget(above)) {
                            if (!spanAbove) {
                                stack.push([x, y - 1]);
                                spanAbove = true;
                            }
                        } else {
                            spanAbove = false;
                        }
                    }

                    if (y < h - 1) {
                        const below = i + w * 4;
                        if (matchTarget(below)) {
                            if (!spanBelow) {
                                stack.push([x, y + 1]);
                                spanBelow = true;
                            }
                        } else {
                            spanBelow = false;
                        }
                    }

                    x++;
                    i += 4;
                }
            }

            ctx.putImageData(imgData, 0, 0);
        }

        // ============================================
        // Êäï„ÅíÁ∏ÑÂ°ó„Çä„Å§„Å∂„Åó
        // ============================================

        function startLasso(x, y) {
            isLassoing = true;
            lassoPoints = [{ x, y }];
            lassoCanvas.style.display = 'block';
            lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
        }

        function updateLasso(x, y) {
            if (!isLassoing) return;

            lassoPoints.push({ x, y });

            // Èùí„ÅÑÁ∑ö„ÅßËªåË∑°„ÇíÊèèÁîª
            lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
            lassoCtx.strokeStyle = '#0066ff';
            lassoCtx.lineWidth = 2;
            lassoCtx.beginPath();
            lassoCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
            for (let i = 1; i < lassoPoints.length; i++) {
                lassoCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
            }
            // ÂßãÁÇπ„Å´Êàª„ÇãÁ∑öÔºà„Éó„É¨„Éì„É•„ÉºÔºâ
            lassoCtx.lineTo(lassoPoints[0].x, lassoPoints[0].y);
            lassoCtx.stroke();
        }

        function finishLasso() {
            if (!isLassoing || lassoPoints.length < 3) {
                isLassoing = false;
                lassoPoints = [];
                lassoCanvas.style.display = 'none';
                return false;
            }

            // ÁîªÈù¢Â∫ßÊ®ô„Åã„Çâ„Ç≠„É£„É≥„Éê„ÇπÂ∫ßÊ®ô„Å´Â§âÊèõ
            const canvasPoints = lassoPoints.map(p => getCanvasPoint(p.x, p.y));

            // Êäï„ÅíÁ∏Ñ„ÅÆÂÜÖÂÅ¥„ÇíÂ°ó„Çä„Å§„Å∂„Åó
            fillPolygon(canvasPoints);

            isLassoing = false;
            lassoPoints = [];
            lassoCanvas.style.display = 'none';
            lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);

            return true;
        }

        function fillPolygon(points) {
            if (points.length < 3) return;

            ctx.fillStyle = getDrawColor();
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.fill();

            // „Ç¢„É≥„ÉÅ„Ç®„Ç§„É™„Ç¢„Çπ„ÅßÁô∫Áîü„Åó„Åü‰∏≠ÈñìËâ≤„Çí2ÂÄ§Âåñ
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                const val = avg > 127 ? 255 : 0;
                data[i] = val;
                data[i + 1] = val;
                data[i + 2] = val;
            }
            ctx.putImageData(imgData, 0, 0);
        }

        // ============================================
        // undo/redoÔºàImageBitmapÊñπÂºèÔºâ
        // ============================================

        async function saveState() {
            const bitmap = await createImageBitmap(canvas);
            undoStack.push(bitmap);

            if (undoStack.length > MAX_HISTORY) {
                undoStack.shift().close();
            }

            redoStack.forEach(b => b.close());
            redoStack = [];
        }

        function undo() {
            if (undoStack.length <= 1) return;

            const current = undoStack.pop();
            redoStack.push(current);

            const prev = undoStack[undoStack.length - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(prev, 0, 0);
        }

        function redo() {
            if (redoStack.length === 0) return;

            const next = redoStack.pop();
            undoStack.push(next);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(next, 0, 0);
        }

        // ============================================
        // GIFÁîüÊàêÔºà„Éî„ÇØ„Çª„É´ÊåØÂãïÔºâ
        // ============================================

        function generateGlitchFrames(imgData, transparent) {
            const w = imgData.width;
            const h = imgData.height;
            const data = imgData.data;

            // ËÉåÊôØËâ≤Âà§ÂÆöÁî®
            const bgR = isDarkMode ? 0 : 255;
            const bgG = isDarkMode ? 0 : 255;
            const bgB = isDarkMode ? 0 : 255;

            // Èªí„Éâ„ÉÉ„ÉàÔºàÊèèÁîªÈÉ®ÂàÜÔºâ„ÅÆÂ∫ßÊ®ô„ÇíÂèéÈõÜ
            const pixels = [];
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // ËÉåÊôØËâ≤„Åß„Å™„ÅÑ = ÊèèÁîªÈÉ®ÂàÜ
                    if (r !== bgR || g !== bgG || b !== bgB) {
                        pixels.push({ x, y, r, g, b });
                    }
                }
            }

            // „Éï„É¨„Éº„É†ÁîüÊàêÈñ¢Êï∞
            function createFrame(seed) {
                const frameData = new Uint8ClampedArray(data);
                const frameCopy = new ImageData(frameData, w, h);
                const targetPixels = [...pixels];

                // 30%„Çí„É©„É≥„ÉÄ„É†ÈÅ∏Êäû
                const count = Math.floor(pixels.length * 0.3);
                const shuffled = targetPixels.sort(() => (Math.random() * seed) - 0.5).slice(0, count);

                // 8ÊñπÂêë„ÅÆ„Ç™„Éï„Çª„ÉÉ„Éà
                const offsets = [
                    [-1, -1], [0, -1], [1, -1],
                    [-1,  0],          [1,  0],
                    [-1,  1], [0,  1], [1,  1]
                ];

                shuffled.forEach(p => {
                    const offset = offsets[Math.floor(Math.random() * seed * 1000) % offsets.length];
                    const newX = p.x + offset[0];
                    const newY = p.y + offset[1];

                    if (newX >= 0 && newX < w && newY >= 0 && newY < h) {
                        const oldIdx = (p.y * w + p.x) * 4;
                        const newIdx = (newY * w + newX) * 4;

                        // ÂÖÉ„ÅÆ‰ΩçÁΩÆ„ÇíËÉåÊôØËâ≤„ÅßÂ°ó„Çä„Å§„Å∂„Åó
                        frameData[oldIdx] = bgR;
                        frameData[oldIdx + 1] = bgG;
                        frameData[oldIdx + 2] = bgB;
                        if (transparent) frameData[oldIdx + 3] = 0;

                        // Êñ∞„Åó„ÅÑ‰ΩçÁΩÆ„Å´ÊèèÁîª
                        frameData[newIdx] = p.r;
                        frameData[newIdx + 1] = p.g;
                        frameData[newIdx + 2] = p.b;
                        frameData[newIdx + 3] = 255;
                    }
                });

                return new ImageData(frameData, w, h);
            }

            // 3„Éï„É¨„Éº„É†ÁîüÊàêÔºàÂÖÉÁµµ„ÄÅÊåØÂãï1„ÄÅÊåØÂãï2Ôºâ
            return [
                imgData,
                createFrame(0.5),
                createFrame(0.8)
            ];
        }

        async function createGIF(frames, w, h, updateProgress) {
            return new Promise((resolve, reject) => {
                try {
                    // gif.js„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç
                    if (typeof GIF === 'undefined') {
                        throw new Error('gif.js „ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
                    }

                    const gif = new GIF({
                        workers: 1,
                        quality: 10,
                        width: w,
                        height: h,
                        workerScript: 'https://unpkg.com/gif.js@0.2.0/dist/gif.worker.js'
                    });

                    console.log('GIFË®≠ÂÆö:', { workers: 1, quality: 10, width: w, height: h });

                    console.log('GIFÁîüÊàêÈñãÂßã:', { frames: frames.length, width: w, height: h });

                    frames.forEach((frameData, index) => {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = w;
                        tempCanvas.height = h;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(frameData, 0, 0);

                        gif.addFrame(tempCanvas, { delay: 50 });
                        console.log(`„Éï„É¨„Éº„É† ${index + 1}/${frames.length} ËøΩÂä†ÂÆå‰∫Ü`);
                    });

                    // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàË®≠ÂÆöÔºà30ÁßíÔºâ
                    const timeout = setTimeout(() => {
                        console.error('GIFÁîüÊàê„Çø„Ç§„É†„Ç¢„Ç¶„ÉàÔºà30ÁßíÔºâ');
                        reject(new Error('GIFÁîüÊàê„Åå„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åó„Åæ„Åó„Åü'));
                    }, 30000);

                    // „Éó„É≠„Ç∞„É¨„Çπ„Éê„ÉºÊõ¥Êñ∞ (50% ‚Üí 100%)
                    gif.on('progress', (progress) => {
                        const percentage = 50 + Math.round(progress * 50);
                        console.log('GIFÁîüÊàêÈÄ≤Ë°å:', percentage + '%');
                        if (updateProgress) {
                            updateProgress(percentage, `GIFÂ§âÊèõ‰∏≠... ${percentage}%`);
                        }
                    });

                    gif.on('finished', blob => {
                        clearTimeout(timeout);
                        console.log('GIFÁîüÊàêÂÆå‰∫Ü:', blob.size, 'bytes');
                        if (updateProgress) {
                            updateProgress(100, 'ÂÆå‰∫ÜÔºÅ');
                        }
                        resolve(blob);
                    });

                    gif.on('error', err => {
                        clearTimeout(timeout);
                        console.error('GIFÁîüÊàê„Ç®„É©„Éº:', err);
                        reject(err);
                    });

                    gif.on('start', () => {
                        console.log('GIF renderÂÆüÈöõ„Å´ÈñãÂßã');
                    });

                    gif.on('abort', () => {
                        clearTimeout(timeout);
                        console.error('GIFÁîüÊàê„Åå‰∏≠Êñ≠„Åï„Çå„Åæ„Åó„Åü');
                        reject(new Error('GIFÁîüÊàê„Åå‰∏≠Êñ≠„Åï„Çå„Åæ„Åó„Åü'));
                    });

                    console.log('GIF renderÈñãÂßã');
                    gif.render();
                } catch (err) {
                    console.error('GIFÁîüÊàêÂàùÊúüÂåñ„Ç®„É©„Éº:', err);
                    reject(err);
                }
            });
        }

        // ============================================
        // „Éù„Ç§„É≥„Çø„Éº„Ç§„Éô„É≥„Éà
        // ============================================

        canvas.addEventListener('pointerdown', (e) => {
            if (isSaveMode) return;

            e.preventDefault();
            canvas.setPointerCapture(e.pointerId);
            activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

            if (e.pointerType === 'pen') {
                pencilDetected = true;
            }

            if (activePointers.size === 1) {
                touchStartTime = Date.now();
                touchStartPos = { x: e.clientX, y: e.clientY };
                maxFingers = 1;
                isPinching = false;
                strokeMade = false;
            }
            maxFingers = Math.max(maxFingers, activePointers.size);

            // 2Êú¨Êåá = „Éî„É≥„ÉÅ/„Éë„É≥Ê∫ñÂÇô
            if (activePointers.size === 2) {
                isDrawing = false;
                isLassoing = false;
                lassoCanvas.style.display = 'none';
                isPinching = false;
                const pts = Array.from(activePointers.values());
                lastPinchDist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
                lastPinchCenter = {
                    x: (pts[0].x + pts[1].x) / 2,
                    y: (pts[0].y + pts[1].y) / 2
                };
                initialPinchDist = lastPinchDist;
                initialPinchCenter = { x: lastPinchCenter.x, y: lastPinchCenter.y };
                return;
            }

            const canDraw = e.pointerType === 'pen' || (e.pointerType === 'touch' && !pencilDetected);

            if (activePointers.size === 1 && canDraw) {
                const p = getCanvasPoint(e.clientX, e.clientY);

                if (currentTool === 'pen') {
                    isDrawing = true;
                    lastX = p.x;
                    lastY = p.y;
                    drawLine(p.x, p.y, p.x, p.y);
                } else if (currentTool === 'fill') {
                    // „Éê„Ç±„ÉÑ„ÉÑ„Éº„É´: „Çø„ÉÉ„Éó„ÅãÊäï„ÅíÁ∏Ñ„Åã„ÄÅpointerup„ÅßÂà§ÂÆö
                    startLasso(e.clientX, e.clientY);
                }
            }
        });

        canvas.addEventListener('pointermove', (e) => {
            if (!activePointers.has(e.pointerId)) return;
            if (isSaveMode) return;

            e.preventDefault();
            activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

            // 2Êú¨Êåá = „Éî„É≥„ÉÅ„Ç∫„Éº„É† / „Éë„É≥
            if (activePointers.size === 2) {
                const pts = Array.from(activePointers.values());
                const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
                const center = {
                    x: (pts[0].x + pts[1].x) / 2,
                    y: (pts[0].y + pts[1].y) / 2
                };

                const distDelta = Math.abs(dist - initialPinchDist);
                const centerDelta = Math.hypot(center.x - initialPinchCenter.x, center.y - initialPinchCenter.y);

                if (distDelta > 10 || centerDelta > 10) {
                    isPinching = true;
                }

                if (isPinching) {
                    const zoomFactor = dist / lastPinchDist;
                    const oldScale = scale;
                    scale = Math.max(0.1, Math.min(20, scale * zoomFactor));

                    translateX = center.x - (center.x - translateX) * (scale / oldScale);
                    translateY = center.y - (center.y - translateY) * (scale / oldScale);

                    translateX += center.x - lastPinchCenter.x;
                    translateY += center.y - lastPinchCenter.y;

                    applyTransform();
                }

                lastPinchDist = dist;
                lastPinchCenter = center;

                return;
            }

            // ÊèèÁîª
            if (isDrawing && activePointers.size === 1) {
                const p = getCanvasPoint(e.clientX, e.clientY);
                drawLine(lastX, lastY, p.x, p.y);
                lastX = p.x;
                lastY = p.y;
                strokeMade = true;
            }

            // Êäï„ÅíÁ∏Ñ
            if (isLassoing && activePointers.size === 1) {
                updateLasso(e.clientX, e.clientY);
                strokeMade = true;
            }
        });

        canvas.addEventListener('pointerup', (e) => {
            if (isSaveMode) return;

            e.preventDefault();

            // ÊèèÁîªÁµÇ‰∫Ü
            if (isDrawing) {
                saveState();
                strokeMade = true;
            }

            // Êäï„ÅíÁ∏ÑÁµÇ‰∫Ü
            if (isLassoing) {
                // ÁßªÂãïË∑ùÈõ¢„ÅßÂà§ÂÆö: Áü≠„ÅÑ = „Çø„ÉÉ„Éó„ÄÅÈï∑„ÅÑ = Êäï„ÅíÁ∏Ñ
                const startP = lassoPoints[0];
                const totalDist = lassoPoints.reduce((acc, p, i) => {
                    if (i === 0) return 0;
                    const prev = lassoPoints[i - 1];
                    return acc + Math.hypot(p.x - prev.x, p.y - prev.y);
                }, 0);

                if (totalDist < 20) {
                    // „Çø„ÉÉ„Éó = ÈÄöÂ∏∏„ÅÆÂ°ó„Çä„Å§„Å∂„Åó
                    const p = getCanvasPoint(startP.x, startP.y);
                    floodFill(p.x, p.y);
                    saveState();
                    strokeMade = true;
                } else {
                    // Êäï„ÅíÁ∏ÑÂ°ó„Çä„Å§„Å∂„Åó
                    if (finishLasso()) {
                        saveState();
                        strokeMade = true;
                    }
                }

                isLassoing = false;
                lassoPoints = [];
                lassoCanvas.style.display = 'none';
                lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
            }

            activePointers.delete(e.pointerId);

            // ÂÖ®ÊåáÈõ¢„Åó„ÅüÊôÇ„ÅÆ„Çø„ÉÉ„ÉóÂà§ÂÆö
            if (activePointers.size === 0) {
                const duration = Date.now() - touchStartTime;

                if (maxFingers >= 2 && duration < 400 && !isPinching && !strokeMade) {
                    if (maxFingers === 2) undo();
                    if (maxFingers === 3) redo();
                }

                maxFingers = 0;
                touchStartPos = null;
                strokeMade = false;
                isPinching = false;
            }

            isDrawing = false;
        });

        canvas.addEventListener('pointercancel', (e) => {
            activePointers.delete(e.pointerId);
            isDrawing = false;
            isLassoing = false;
            isPinching = false;
            lassoCanvas.style.display = 'none';
        });

        // ============================================
        // UI„Ç§„Éô„É≥„Éà
        // ============================================

        // „ÉÑ„Éº„É´Âàá„ÇäÊõø„Åà
        document.querySelectorAll('[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                currentTool = btn.dataset.tool;
                document.querySelectorAll('[data-tool]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        // Ëâ≤Âàá„ÇäÊõø„Åà
        document.getElementById('colorBtn').addEventListener('click', () => {
            currentColor = currentColor === 'black' ? 'white' : 'black';
            updateColorButton();

            // „Çµ„Ç§„Ç∫„ÇíËâ≤„Å´Âøú„Åò„Å¶Âæ©ÂÖÉ
            document.getElementById('brushSize').value = colorSizes[currentColor];
            document.getElementById('sizeDisplay').textContent = colorSizes[currentColor];
        });

        // „Éñ„É©„Ç∑„Çµ„Ç§„Ç∫
        document.getElementById('brushSize').addEventListener('input', (e) => {
            const size = parseInt(e.target.value);
            colorSizes[currentColor] = size;
            document.getElementById('sizeDisplay').textContent = size;
        });

        // „ÇØ„É™„Ç¢
        document.getElementById('clearBtn').addEventListener('click', () => {
            ctx.fillStyle = isDarkMode ? '#000' : '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveState();
        });

        // ÂèçËª¢
        document.getElementById('invertBtn').addEventListener('click', () => {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark');
            document.body.classList.toggle('light');

            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];
                data[i + 1] = 255 - data[i + 1];
                data[i + 2] = 255 - data[i + 2];
            }
            ctx.putImageData(imgData, 0, 0);

            updateColorButton();
            saveState();
        });

        // „Ç∫„Éº„É†„É™„Çª„ÉÉ„Éà
        document.getElementById('resetZoomBtn').addEventListener('click', () => {
            scale = 1;
            translateX = 0;
            translateY = 0;
            applyTransform();
        });

        // ============================================
        // ‰øùÂ≠òÊ©üËÉΩ
        // ============================================

        document.getElementById('saveBtn').addEventListener('click', () => {
            isSaveMode = true;
            document.getElementById('save-overlay').style.display = 'block';
            document.getElementById('save-ui').style.display = 'block';
            document.getElementById('selection-canvas').style.display = 'block';
            document.getElementById('toolbar-left').style.display = 'none';
            document.getElementById('toolbar-right').style.display = 'none';
            document.getElementById('resetZoomBtn').style.display = 'none';
        });

        function exitSaveMode() {
            isSaveMode = false;
            document.getElementById('save-overlay').style.display = 'none';
            document.getElementById('save-ui').style.display = 'none';
            document.getElementById('selection-canvas').style.display = 'none';
            document.getElementById('generating').style.display = 'none';
            document.getElementById('toolbar-left').style.display = 'flex';
            document.getElementById('toolbar-right').style.display = 'flex';
            applyTransform();

            const selCanvas = document.getElementById('selection-canvas');
            const selCtx = selCanvas.getContext('2d');
            selCtx.clearRect(0, 0, selCanvas.width, selCanvas.height);

            selectionStart = null;
            selectionEnd = null;
        }

        document.getElementById('cancelSaveBtn').addEventListener('click', exitSaveMode);

        document.getElementById('saveAllBtn').addEventListener('click', () => {
            saveRegion(0, 0, canvas.width, canvas.height);
        });

        const overlay = document.getElementById('save-overlay');

        overlay.addEventListener('pointerdown', (e) => {
            if (!isSaveMode) return;
            selectionStart = { x: e.clientX, y: e.clientY };
            selectionEnd = { x: e.clientX, y: e.clientY };
        });

        overlay.addEventListener('pointermove', (e) => {
            if (!isSaveMode || !selectionStart) return;
            selectionEnd = { x: e.clientX, y: e.clientY };

            const selCanvas = document.getElementById('selection-canvas');
            const selCtx = selCanvas.getContext('2d');
            selCtx.clearRect(0, 0, selCanvas.width, selCanvas.height);

            selCtx.strokeStyle = isDarkMode ? '#fff' : '#000';
            selCtx.lineWidth = 2;
            selCtx.setLineDash([8, 8]);
            selCtx.strokeRect(
                selectionStart.x,
                selectionStart.y,
                selectionEnd.x - selectionStart.x,
                selectionEnd.y - selectionStart.y
            );
        });

        overlay.addEventListener('pointerup', (e) => {
            if (!isSaveMode || !selectionStart) return;

            const x1 = Math.floor((Math.min(selectionStart.x, selectionEnd.x) - translateX) / scale);
            const y1 = Math.floor((Math.min(selectionStart.y, selectionEnd.y) - translateY) / scale);
            const x2 = Math.floor((Math.max(selectionStart.x, selectionEnd.x) - translateX) / scale);
            const y2 = Math.floor((Math.max(selectionStart.y, selectionEnd.y) - translateY) / scale);

            const w = x2 - x1;
            const h = y2 - y1;

            if (w > 5 && h > 5) {
                const cx = Math.max(0, Math.min(x1, canvas.width));
                const cy = Math.max(0, Math.min(y1, canvas.height));
                const cw = Math.min(w, canvas.width - cx);
                const ch = Math.min(h, canvas.height - cy);

                if (cw > 0 && ch > 0) {
                    saveRegion(cx, cy, cw, ch);
                }
            }

            selectionStart = null;
            selectionEnd = null;

            const selCanvas = document.getElementById('selection-canvas');
            const selCtx = selCanvas.getContext('2d');
            selCtx.clearRect(0, 0, selCanvas.width, selCanvas.height);
        });

        async function saveRegion(x, y, w, h) {
            const glitchMode = document.getElementById('glitchMode').checked;
            const transparent = document.getElementById('transparentBg').checked;

            const flash = document.getElementById('flash');
            flash.style.opacity = '0.7';
            setTimeout(() => { flash.style.opacity = '0'; }, 100);

            let blob, fileName;

            try {
                if (glitchMode) {
                    // GIFÁîüÊàê
                    document.getElementById('generating').style.display = 'block';

                    // „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„Çí„É™„Çª„ÉÉ„Éà
                    const progressFill = document.getElementById('progress-fill');
                    const progressText = document.getElementById('progress-text');

                    function updateProgress(percent, text) {
                        if (progressFill) progressFill.style.width = percent + '%';
                        if (progressText) progressText.textContent = text;
                    }

                    console.log('GIF‰øùÂ≠òÈñãÂßã:', { x, y, w, h, transparent });

                    updateProgress(0, 'Ê∫ñÂÇô‰∏≠...');
                    await new Promise(resolve => setTimeout(resolve, 100)); // UIÊõ¥Êñ∞„ÇíÂæÖ„Å§

                    updateProgress(10, 'ÁîªÂÉè„Éá„Éº„ÇøË™≠„ÅøËæº„Åø‰∏≠...');
                    const imgData = ctx.getImageData(x, y, w, h);
                    console.log('ÁîªÂÉè„Éá„Éº„ÇøÂèñÂæó:', imgData.width, 'x', imgData.height);
                    await new Promise(resolve => setTimeout(resolve, 50));

                    // ËÉåÊôØÈÄèÈÅéÂá¶ÁêÜ
                    if (transparent) {
                        updateProgress(20, 'ËÉåÊôØÈÄèÈÅéÂá¶ÁêÜ‰∏≠...');
                        const data = imgData.data;
                        const bgR = isDarkMode ? 0 : 255;
                        const bgG = isDarkMode ? 0 : 255;
                        const bgB = isDarkMode ? 0 : 255;

                        for (let i = 0; i < data.length; i += 4) {
                            if (data[i] === bgR && data[i + 1] === bgG && data[i + 2] === bgB) {
                                data[i + 3] = 0;
                            }
                        }
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }

                    updateProgress(30, '„Ç∞„É™„ÉÉ„ÉÅ„Éï„É¨„Éº„É†ÁîüÊàê‰∏≠...');
                    await new Promise(resolve => setTimeout(resolve, 50));

                    const frames = generateGlitchFrames(imgData, transparent);
                    console.log('„Ç∞„É™„ÉÉ„ÉÅ„Éï„É¨„Éº„É†ÁîüÊàêÂÆå‰∫Ü:', frames.length, '„Éï„É¨„Éº„É†');

                    updateProgress(50, 'GIFÂ§âÊèõ‰∏≠...');
                    blob = await createGIF(frames, w, h, updateProgress);
                    fileName = `desu_${Date.now()}.gif`;
                    console.log('GIFÁîüÊàêÂÆå‰∫Ü');

                    document.getElementById('generating').style.display = 'none';
                } else {
                    // PNGÁîüÊàêÔºàÂæìÊù•ÈÄö„ÇäÔºâ
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = w;
                    tempCanvas.height = h;
                    const tempCtx = tempCanvas.getContext('2d');

                    if (transparent) {
                        const imgData = ctx.getImageData(x, y, w, h);
                        const data = imgData.data;
                        const bgR = isDarkMode ? 0 : 255;
                        const bgG = isDarkMode ? 0 : 255;
                        const bgB = isDarkMode ? 0 : 255;

                        for (let i = 0; i < data.length; i += 4) {
                            if (data[i] === bgR && data[i + 1] === bgG && data[i + 2] === bgB) {
                                data[i + 3] = 0;
                            }
                        }
                        tempCtx.putImageData(imgData, 0, 0);
                    } else {
                        tempCtx.drawImage(canvas, x, y, w, h, 0, 0, w, h);
                    }

                    blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png'));
                    fileName = `desu_${Date.now()}.png`;
                }

                // ÂÖ±Êúâ or „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
                if (navigator.canShare && navigator.canShare({ files: [new File([blob], fileName)] })) {
                    try {
                        const file = new File([blob], fileName);
                        await navigator.share({
                            files: [file],
                            title: 'DESU Paint'
                        });
                        exitSaveMode();
                        return;
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            console.log('Share failed, trying fallback:', err);
                        } else {
                            exitSaveMode();
                            return;
                        }
                    }
                }

                const url = URL.createObjectURL(blob);
                window.open(url, '_blank');
                setTimeout(() => URL.revokeObjectURL(url), 1000);

                exitSaveMode();
            } catch (err) {
                console.error('‰øùÂ≠ò„Ç®„É©„Éº:', err);
                document.getElementById('generating').style.display = 'none';

                const progressText = document.getElementById('progress-text');
                if (progressText) {
                    progressText.textContent = '„Ç®„É©„Éº: ' + err.message;
                }

                setTimeout(() => {
                    alert('‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Ç≥„É≥„ÇΩ„Éº„É´„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n„Ç®„É©„Éº: ' + err.message);
                    exitSaveMode();
                }, 500);
            }
        }

        // ============================================
        // ÁîªÈù¢ÂõûËª¢ÂØæÂøú
        // ============================================

        window.addEventListener('orientationchange', () => {
            setTimeout(async () => {
                const bitmap = await createImageBitmap(canvas);

                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                lassoCanvas.width = window.innerWidth;
                lassoCanvas.height = window.innerHeight;

                ctx.fillStyle = isDarkMode ? '#000' : '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(bitmap, 0, 0);
                bitmap.close();

                const selCanvas = document.getElementById('selection-canvas');
                selCanvas.width = window.innerWidth;
                selCanvas.height = window.innerHeight;

                applyTransform();
            }, 100);
        });

        // ============================================
        // Ëµ∑Âãï
        // ============================================

        initCanvas();
    </script>
</body>
</html>
